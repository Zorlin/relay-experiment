use futures::stream::StreamExt;
use futures::future::Either;
use libp2p::{
    core::transport::{upgrade::Version, Transport as CoreTransport}, // Keep CoreTransport trait
    identity::{Keypair},
    noise, ping, relay, identify, autonat, dcutr,
    swarm::{NetworkBehaviour, SwarmEvent},
    Multiaddr, PeerId, SwarmBuilder, // Removed top-level Transport trait import
};
use std::{env, error::Error, time::Duration, str::FromStr};
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use std::fs;
use std::io::Write;
use parking_lot::Mutex;
use tokio::time::interval;
use log::{info, error, warn, LevelFilter};
use warp::Filter;
use dotenvy::dotenv;
use libp2p::core::muxing::StreamMuxerBox;
use base64::{engine::general_purpose::{STANDARD as base64_engine, STANDARD_NO_PAD}, Engine as _};
use libp2p::gossipsub::{Behaviour as Gossipsub, MessageAuthenticity, Sha256Topic, Event as GossipsubEvent, ValidationMode};
use prost::Message;
use bytes::Bytes;
use rand;

use libp2p_webrtc::tokio::{Transport as WebRtcTransport, Certificate as WebRtcCertificate};
use libp2p_webtransport_websys::{Transport as WebTransport, Config as WebTransportConfig};
// Removed unused rand::Rng import

// Include the Rust code generated by prost from identity.proto
// This module will contain KeyType enum and PrivateKey struct
pub mod identity_proto {
    include!(concat!(env!("OUT_DIR"), "/relay.identity.proto.rs"));
}

// Define the network behaviour combining multiple protocols
#[derive(NetworkBehaviour)]
// The `relay::Behaviour` emits `void::Void`, so we don't need a custom event for it.
// The overall event type `RelayEvent` will be generated by the derive macro.
#[behaviour(to_swarm = "RelayEvent")]
struct RelayBehaviour {
    // Note: relay::Behaviour<RelayReservation> is the full type, but Behaviour often suffices.
    relay: relay::Behaviour,
    ping: ping::Behaviour,
    identify: identify::Behaviour,
    pubsub: Gossipsub, // Added gossipsub behaviour
    dcutr: dcutr::Behaviour, // Added DCUtR
    autonat: autonat::Behaviour, // Added AutoNAT
}

// Define the custom event type that the behaviour emits to the Swarm.
// The derive macro automatically generates variants for behaviours that emit events.
// Since relay::Behaviour emits void::Void, we only need variants for Ping and Identify.
#[derive(Debug)]
enum RelayEvent {
    Ping(ping::Event),
    Identify(identify::Event),
    Relay(relay::Event), // Added Relay variant
    Pubsub(GossipsubEvent), // Added PubSub variant
    Dcutr(dcutr::Event),       // Added DCUtR variant
    AutoNat(autonat::Event),   // Added AutoNat variant
}

// Keep only one set of From implementations
impl From<relay::Event> for RelayEvent {
    fn from(event: relay::Event) -> Self {
        RelayEvent::Relay(event)
    }
}

impl From<ping::Event> for RelayEvent {
    fn from(event: ping::Event) -> Self {
        RelayEvent::Ping(event)
    }
}

impl From<identify::Event> for RelayEvent {
    fn from(event: identify::Event) -> Self {
        RelayEvent::Identify(event)
    }
}

impl From<GossipsubEvent> for RelayEvent {
    fn from(event: GossipsubEvent) -> Self {
        RelayEvent::Pubsub(event)
    }
}

impl From<dcutr::Event> for RelayEvent {
    fn from(event: dcutr::Event) -> Self {
        RelayEvent::Dcutr(event)
    }
}

impl From<autonat::Event> for RelayEvent {
    fn from(event: autonat::Event) -> Self {
        RelayEvent::AutoNat(event)
    }
}

// Import the specific DCUtR event type with an alias
// use libp2p::dcutr::Event as DcutrEvent;

#[cfg(test)]
mod tests {
    use super::*;
    use base64::engine::general_purpose::STANDARD as base64_engine;
    use base64::Engine;
    use serial_test::serial; // Import the serial attribute
    // Removed duplicate super import
    use libp2p::{
        ping, identify, // Removed relay import as it's not used directly in tests now
        identity::Keypair,
        PeerId, Multiaddr, StreamProtocol,
        swarm::ConnectionId,
        // Removed relay::client import
    };
    use std::num::NonZeroU32; // Import NonZeroU32
    use libp2p::gossipsub::{ValidationMode, ConfigBuilder}; // Allow permissive validation for Anonymous pubsub in tests

    // Helper to create a dummy PeerId for testing
    fn dummy_peer_id() -> PeerId {
        PeerId::from(Keypair::generate_ed25519().public())
    }

    // Helper to create a dummy Multiaddr for testing
    fn dummy_multiaddr() -> Multiaddr {
        "/ip4/127.0.0.1/tcp/0".parse().unwrap()
    }

    // Removed test_from_relay_client_event as relay::Behaviour no longer emits these events directly
    // in a way that maps to our RelayEvent enum.

    #[test]
    fn test_from_ping_event() {
        let peer_id = dummy_peer_id();
        let ping_event = ping::Event {
            peer: peer_id,
            connection: ConnectionId::new_unchecked(0), // Use new_unchecked for simplicity in test
            // Ping result is now directly Result<Duration, Failure>
            result: Result::Ok(Duration::from_millis(10)),
        };
        let event: RelayEvent = ping_event.into();
        assert!(matches!(event, RelayEvent::Ping(ping::Event { result: Ok(_), .. }))); // Adjusted match slightly
    }

    #[test]
    fn test_from_identify_event() {
        let peer_id = dummy_peer_id();
        let public_key = Keypair::generate_ed25519().public();
        let identify_event = identify::Event::Received {
            peer_id,
            info: identify::Info {
                public_key,
                protocol_version: "test/1.0".to_string(),
                agent_version: "test-agent/0.1".to_string(),
                listen_addrs: vec![dummy_multiaddr()],
                // Use StreamProtocol::new for protocol names
                protocols: vec![StreamProtocol::new("/test/1")],
                observed_addr: dummy_multiaddr(),
            },
            connection_id: ConnectionId::new_unchecked(0), // Added missing field
        };
        let event: RelayEvent = identify_event.into();
        assert!(matches!(event, RelayEvent::Identify(identify::Event::Received { .. })));
    }

    // Example test for a SwarmEvent pattern match (demonstrates structure, not a real unit test)
    // This kind of test is more suited for integration tests where a real Swarm exists.
    #[test]
    fn test_swarm_event_match_structure() {
        let peer_id = dummy_peer_id();
        let dummy_endpoint = libp2p::core::ConnectedPoint::Listener {
             local_addr: dummy_multiaddr(),
             send_back_addr: dummy_multiaddr(),
        };
        // Correct the type annotation for SwarmEvent (only one generic argument)
        let event: SwarmEvent<RelayEvent> = SwarmEvent::ConnectionEstablished {
            peer_id,
            connection_id: ConnectionId::new_unchecked(0),
            endpoint: dummy_endpoint,
            // Use NonZeroU32 for num_established
            num_established: NonZeroU32::new(1).unwrap(),
            concurrent_dial_errors: None,
            established_in: Duration::from_secs(0),
        };

        match event {
             SwarmEvent::ConnectionEstablished { peer_id: p, endpoint: e, num_established, .. } => {
                 assert_eq!(p, peer_id);
                 assert!(matches!(e, libp2p::core::ConnectedPoint::Listener{..}));
                 // Compare with the correct NonZeroU32 value
                 assert_eq!(num_established, NonZeroU32::new(1).unwrap());
             },
             _ => panic!("Event did not match expected pattern"),
        }
    }

   #[test]
   fn test_relay_behaviour_construction() {
       let local_key = Keypair::generate_ed25519();
       let local_peer_id = PeerId::from(local_key.public());
       let identify_config = identify::Config::new(
           "/test-protocol/1.0.0".to_string(),
           local_key.public(),
       ).with_push_listen_addr_updates(true);

       // Add defaults for missing fields in test config
       let relay_config = relay::Config {
           max_circuits: 32,
           max_reservations: usize::MAX,
           reservation_duration: Duration::from_secs(60 * 60), 
           max_circuit_duration: Duration::from_secs(2 * 60),
           max_circuit_bytes: 1 << 17, 
           max_reservations_per_peer: 1,
           max_circuits_per_peer: 16,
           circuit_src_rate_limiters: Default::default(),
           reservation_rate_limiters: Default::default(),
       };
       let autonat_config = autonat::Config::default();

       let _behaviour = RelayBehaviour {
           relay: relay::Behaviour::new(local_peer_id, relay_config),
           ping: ping::Behaviour::new(ping::Config::new()),
           identify: identify::Behaviour::new(identify_config.clone()),
           pubsub: Gossipsub::new(
               MessageAuthenticity::Anonymous,
               ConfigBuilder::from(Config::default()).validation_mode(ValidationMode::Permissive).build().unwrap()
           ).unwrap(),
           dcutr: dcutr::Behaviour::new(local_peer_id),
           autonat: autonat::Behaviour::new(local_peer_id, autonat_config),
       };

       assert!(true);
   }

   #[test]
   fn test_identify_config_creation() {
       let local_key = Keypair::generate_ed25519();
       let public_key = local_key.public();
       let protocol_version = "/test-identify/1.0.0".to_string();
       let agent_version = "test-agent/0.1".to_string();

       let config = identify::Config::new(
           protocol_version.clone(),
           public_key.clone(),
       )
       .with_agent_version(agent_version.clone())
       .with_push_listen_addr_updates(true); // Added push check

       assert_eq!(config.protocol_version(), protocol_version);
       assert_eq!(config.local_public_key(), &public_key);
       assert_eq!(config.agent_version(), agent_version);
       assert_eq!(config.interval(), Duration::from_secs(5 * 60));
       assert!(config.push_listen_addr_updates()); // Check push enabled
   }

   use super::identity_proto; // Import generated proto module
   use prost::Message; // Import Message trait for encoding test key
   // Removed unused bytes::Bytes import

   #[test]
   #[serial] // Run this test serially
   fn test_clef_privée_relai_env_key_loading_custom_protobuf() {
       // Generate a keypair to get raw secret bytes
       let original_keypair = Keypair::generate_ed25519();
       let expected_public_key = original_keypair.public(); // For comparison later

       // Extract the raw 32-byte secret key
       // This is tricky as Keypair doesn't directly expose the secret bytes.
       // We need to extract them from the standard protobuf encoding.
       let proto_bytes = original_keypair.to_protobuf_encoding().unwrap();
       // The secret key is typically bytes 4 to 36 in the standard encoding.
       let secret_slice = &proto_bytes[4..36];
       // Convert the slice to a fixed-size array [u8; 32]
       let secret_array: [u8; 32] = secret_slice.try_into()
           .expect("Slice from protobuf encoding should be 32 bytes for Ed25519");

       // Now use the fixed-size array with ed25519_dalek if needed, or directly below.
       // let dalek_signing_key = ed25519_dalek::SigningKey::from_bytes(&secret_array);
       // let secret_bytes_32 = dalek_signing_key.to_bytes(); // This is just secret_array again

       // Create the custom protobuf message
       let private_key_message = identity_proto::PrivateKey {
           r#type: identity_proto::KeyType::Ed25519 as i32,
           // Convert the fixed-size array (or Bytes) to Vec<u8> as expected by the struct field
           data: secret_array.to_vec(), // Use the 32 raw secret bytes as a Vec<u8>
       };

       // Encode this custom message to protobuf bytes
       let custom_protobuf_bytes = private_key_message.encode_to_vec();

       // Base64 encode these custom protobuf bytes
       let key_b64 = base64_engine.encode(&custom_protobuf_bytes);
       std::env::set_var("CLEF_PRIVEE_RELAI", &key_b64);

       // --- Actually call the function under test ---
       let loaded_keypair_result = load_keypair_from_env();

       // Assert the result is Ok and the keypair is correct
       assert!(loaded_keypair_result.is_ok(), "load_keypair_from_env failed for custom format: {:?}", loaded_keypair_result.err());
       let loaded_keypair = loaded_keypair_result.unwrap();

       // Compare the public key derived from the loaded keypair with the original
       assert_eq!(loaded_keypair.public(), expected_public_key, "Loaded keypair public key does not match the original");

       // Optional: Assert the PeerIds match as well
       assert_eq!(PeerId::from(loaded_keypair.public()), PeerId::from(expected_public_key), "Loaded PeerId does not match the original");

       // Clean up environment variable
       std::env::remove_var("CLEF_PRIVEE_RELAI");
   }

   #[test]
   #[serial] // Run this test serially
   fn test_clef_privée_relai_env_key_loading_invalid_base64() {
       // Set invalid base64 data
       std::env::set_var("CLEF_PRIVEE_RELAI", "this is not base64!");

       // --- Actually call the function under test ---
       let loaded_keypair_result = load_keypair_from_env();

       // Assert the result is Err
       assert!(loaded_keypair_result.is_err(), "load_keypair_from_env should have failed for invalid base64");
       // Optionally check the error message contains "base64"
       assert!(loaded_keypair_result.err().unwrap().to_string().contains("base64"));


       // Clean up environment variable
       std::env::remove_var("CLEF_PRIVEE_RELAI");
   }

    #[test]
    #[serial] // Run this test serially
   fn test_clef_privée_relai_env_key_loading_invalid_protobuf() {
       // Set valid base64, but invalid protobuf data (e.g., just "hello")
       let invalid_protobuf_b64 = base64_engine.encode(b"hello");
       std::env::set_var("CLEF_PRIVEE_RELAI", &invalid_protobuf_b64);

       // --- Actually call the function under test ---
       let loaded_keypair_result = load_keypair_from_env();

       // Assert the result is Err
       assert!(loaded_keypair_result.is_err(), "load_keypair_from_env should have failed for invalid protobuf bytes");
       // Optionally check the error message contains "protobuf" or "decode"
       let err_msg = loaded_keypair_result.err().unwrap().to_string();
       assert!(err_msg.contains("protobuf") || err_msg.contains("decode"));


       // Clean up environment variable
       std::env::remove_var("CLEF_PRIVEE_RELAI");
   }

    #[test]
    #[serial] // Run this test serially
   fn test_clef_privée_relai_env_key_loading_not_set() {
       // Ensure the environment variable is not set
       std::env::remove_var("CLEF_PRIVEE_RELAI");
       // Add logging to confirm the variable is unset before calling the function
       let var_check = std::env::var("CLEF_PRIVEE_RELAI");
       println!("test_clef_privée_relai_env_key_loading_not_set: CLEF_PRIVEE_RELAI check before call: {:?}", var_check);

       // --- Actually call the function under test ---
       let loaded_keypair_result = load_keypair_from_env();

       // Assert the result is Ok (should generate a random key)
       assert!(loaded_keypair_result.is_ok(), "load_keypair_from_env should succeed when env var is not set, but got Err: {:?}", loaded_keypair_result.err());

       // We can't easily check if it's *random*, but we know it succeeded.
       let _loaded_keypair = loaded_keypair_result.unwrap();
   }

    // Integration test for peer connection
    #[tokio::test]
    async fn test_peer_connects_to_relay() {
        // Use a short timeout for the test
        let test_timeout = Duration::from_secs(15); // Increased timeout slightly

        tokio::time::timeout(test_timeout, async {
            // 1. Setup: Generate keys and build swarms
            let relay_key = Keypair::generate_ed25519();
            let relay_peer_id = PeerId::from(relay_key.public());
            let mut relay_swarm = build_swarm(relay_key, None).await.expect("Relay swarm build failed"); // No pubsub topics needed for this test

            let client_key = Keypair::generate_ed25519();
            let client_peer_id = PeerId::from(client_key.public());
            let mut client_swarm = build_swarm(client_key, None).await.expect("Client swarm build failed"); // No pubsub topics needed

            // 2. Start Relay Listener
            relay_swarm.listen_on("/ip4/127.0.0.1/tcp/0".parse().unwrap()).expect("Relay listen failed");

            // 3. Get Relay Listening Address
            let relay_addr = loop {
                if let Some(SwarmEvent::NewListenAddr { address, .. }) = relay_swarm.next().await {
                    // Ensure it's not a loopback WebSocket address if WS is enabled by default elsewhere
                    // For this test, we expect the TCP listener.
                    if address.to_string().contains("/tcp/") {
                         println!("Relay listening on: {}", address); // Use println for test output
                         break address;
                    }
                }
                // Add a small delay to prevent tight looping if the event isn't immediate
                tokio::time::sleep(Duration::from_millis(50)).await;
            };

            // 4. Client Dials Relay
            client_swarm.dial(relay_addr.clone()).expect("Client dial failed");
            println!("Client ({}) dialing Relay ({}) at {}", client_peer_id, relay_peer_id, relay_addr);

            // 5. Event Loop: Wait for connection
            let mut client_connected = false;
            let mut relay_saw_client = false;

            loop {
                tokio::select! {
                    // Poll Relay Swarm
                    relay_event = relay_swarm.select_next_some() => {
                        if let SwarmEvent::ConnectionEstablished { peer_id, .. } = relay_event {
                            println!("Relay saw connection from: {}", peer_id);
                            if peer_id == client_peer_id {
                                relay_saw_client = true;
                            }
                        }
                        // Optional: Log other relay events for debugging
                        // else { println!("Relay event: {:?}", relay_event); }
                    },
                    // Poll Client Swarm
                    client_event = client_swarm.select_next_some() => {
                         if let SwarmEvent::ConnectionEstablished { peer_id, .. } = client_event {
                            println!("Client saw connection to: {}", peer_id);
                            if peer_id == relay_peer_id {
                                client_connected = true;
                            }
                        }
                        // Optional: Log other client events for debugging
                        // else { println!("Client event: {:?}", client_event); }
                    },
                    // Timeout guard (handled by outer tokio::time::timeout)
                    // _ = tokio::time::sleep(Duration::from_secs(10)) => { // Inner timeout as safeguard
                    //     panic!("Test timed out waiting for connection");
                    // }
                }

                // Check if connection is established from both perspectives
                if client_connected && relay_saw_client {
                    println!("Connection successfully established between client and relay.");
                    break; // Success
                }
            }

            // 6. Assertions (already implicitly checked by reaching the end without panic/timeout)
            assert!(client_connected, "Client should have connected to the relay");
            assert!(relay_saw_client, "Relay should have seen the client connection");

        }).await.expect("Test timed out"); // Panic if the outer timeout expires
    }
}

// Type alias for the shared state of listening addresses
type ListeningAddresses = Arc<Mutex<Vec<Multiaddr>>>;

// Function now returns a Result
fn load_keypair_from_env() -> Result<Keypair, Box<dyn Error>> {
    match env::var("CLEF_PRIVEE_RELAI") {
        Ok(key_b64) => {
            // 1. Decode Base64
            let key_bytes = base64_engine.decode(key_b64.as_bytes())
                .or_else(|_| STANDARD_NO_PAD.decode(key_b64.as_bytes()))
                .map_err(|e| format!("Failed to decode CLEF_PRIVEE_RELAI from base64: {}", e))?;

            // --- Attempt 1: Check if the decoded bytes look like the JS library's raw Ed25519 key (64 bytes: secret + public) ---
            if key_bytes.len() == 64 {
                info!("Decoded base64 data is 64 bytes long. Assuming JS format (secret + public). Attempting to load using first 32 bytes as Ed25519 secret key.");
                // Extract the first 32 bytes, assuming they are the secret key.
                let mut secret_bytes_array: [u8; 32] = key_bytes[0..32].try_into()
                    .map_err(|_| "Internal error: Failed to extract first 32 bytes from 64-byte key data".to_string())?; // Should not fail

                match Keypair::ed25519_from_bytes(&mut secret_bytes_array) {
                    Ok(keypair) => {
                        info!("Successfully loaded Ed25519 identity from CLEF_PRIVEE_RELAI (extracted 32 secret bytes from 64-byte JS format).");
                        return Ok(keypair); // Success! Return early.
                    }
                    Err(e) => {
                        warn!("Failed to create Ed25519 keypair from extracted 32 bytes (from 64-byte data): {}. Proceeding to other formats...", e);
                        // Fall through to try other decoding methods
                    }
                }
            // --- Attempt 2: Check if the decoded bytes look like *just* the raw Ed25519 secret key (32 bytes) ---
            } else if key_bytes.len() == 32 {
                info!("Decoded base64 data is 32 bytes long. Attempting to load as raw Ed25519 secret key.");
                let mut secret_bytes_array: [u8; 32] = key_bytes.as_slice().try_into()
                    .map_err(|_| "Internal error: Failed to convert 32-byte Vec<u8> to [u8; 32]".to_string())?;

                match Keypair::ed25519_from_bytes(&mut secret_bytes_array) {
                    Ok(keypair) => {
                        info!("Successfully loaded Ed25519 identity from CLEF_PRIVEE_RELAI (raw 32 secret bytes format).");
                        return Ok(keypair); // Success! Return early.
                    }
                    Err(e) => {
                        warn!("Failed to create Ed25519 keypair from 32-byte raw data: {}. Proceeding to other formats...", e);
                        // Fall through
                    }
                }
            } else {
                info!("Decoded base64 data is {} bytes long. Not treating as raw Ed25519 secret (32 or 64 bytes). Trying protobuf formats...", key_bytes.len());
            }

            // --- Attempt 3: Decode using standard libp2p Keypair protobuf encoding ---
            match Keypair::from_protobuf_encoding(&key_bytes) {
                Ok(keypair) => {
                    info!("Successfully loaded identity from CLEF_PRIVEE_RELAI (standard libp2p protobuf format).");
                    Ok(keypair)
                }
                Err(libp2p_decode_err) => {
                    // Standard decoding failed, log it and try the custom format
                    warn!("Failed to decode CLEF_PRIVEE_RELAI as standard libp2p keypair ({}). Trying custom protobuf format...", libp2p_decode_err);

                    // --- Attempt 3: Decode using custom identity.proto definition ---
                    // Need Bytes::from for prost decoding. Clone key_bytes as it might be needed if this fails.
                    match identity_proto::PrivateKey::decode(Bytes::from(key_bytes.clone())) {
                        Ok(private_key_proto) => {
                            // Custom protobuf decoded, now extract the key material
                            match identity_proto::KeyType::try_from(private_key_proto.r#type) {
                                Ok(identity_proto::KeyType::Ed25519) => {
                                    if private_key_proto.data.len() == 32 {
                                        let mut secret_bytes: [u8; 32] = private_key_proto.data.as_slice().try_into()
                                            .map_err(|_| format!("Custom protobuf: Failed to convert data Vec<u8> (len {}) to [u8; 32]", private_key_proto.data.len()))?;
                                        let keypair = Keypair::ed25519_from_bytes(&mut secret_bytes)
                                            .map_err(|e| format!("Custom protobuf: Failed to create Ed25519 keypair from data bytes: {}", e))?;
                                        info!("Successfully loaded Ed25519 identity from CLEF_PRIVEE_RELAI (custom protobuf format).");
                                        Ok(keypair)
                                    } else {
                                        Err(format!("Custom protobuf: Extracted Ed25519 data is not 32 bytes long (found {} bytes)", private_key_proto.data.len()).into())
                                    }
                                }
                                Ok(other_type) => Err(format!("Custom protobuf: Unsupported key type ({:?})", other_type).into()),
                                Err(_) => Err(format!("Custom protobuf: Invalid key type enum value ({})", private_key_proto.r#type).into()),
                            }
                        }
                        Err(custom_decode_err) => {
                            // All decoding attempts failed (raw 64, raw 32, standard proto, custom proto)
                            Err(format!("Failed to decode CLEF_PRIVEE_RELAI: Not valid raw 64-byte JS format, not valid raw 32-byte secret, Standard proto decode error: '{}', Custom proto decode error: '{}'", libp2p_decode_err, custom_decode_err).into())
                        }
                    }
                }
            }
        },
        Err(env::VarError::NotPresent) => {
            // Environment variable not set, generate a new random keypair
            info!("CLEF_PRIVEE_RELAI not set. Generating random identity.");
            Ok(Keypair::generate_ed25519())
        },
        Err(e) => {
            // Other error reading environment variable
            Err(format!("Error reading CLEF_PRIVEE_RELAI environment variable: {}", e).into())
        }
    }
}

// Helper function to build a configured Swarm
async fn build_swarm(local_key: Keypair, pubsub_topics: Option<String>) -> Result<libp2p::swarm::Swarm<RelayBehaviour>, Box<dyn Error>> {
    let local_peer_id = PeerId::from(local_key.public());
    info!("Building swarm for Peer ID: {}", local_peer_id);

    // Create the Identify behaviour configuration
    let identify_config = identify::Config::new(
        "/ipfs/id/1.0.0".to_string(), // Use default protocol name for compatibility with TypeScript implementation
        local_key.public(),
    )
    .with_agent_version(format!("rust-libp2p-relay/{}", env!("CARGO_PKG_VERSION")))
    .with_push_listen_addr_updates(true) // Enable IdentifyPush
    .with_interval(Duration::from_secs(600));

    // Note: We can't currently adjust the max message size and stream limits via the Config API.

    // Build the transport stack
    let transport = {
        // TCP Transport
        let tcp_transport = libp2p::tcp::tokio::Transport::new(libp2p::tcp::Config::default().nodelay(true))
            .upgrade(Version::V1Lazy)
            .authenticate(noise::Config::new(&local_key)?)
            .multiplex(libp2p::yamux::Config::default())
            .timeout(Duration::from_secs(20))
            .boxed();

        // WebSocket Transport - configure with proper DNS handling
        let ws_transport = {
            // First create a TCP transport
            let tcp_transport = libp2p::tcp::tokio::Transport::new(
                libp2p::tcp::Config::default()
                    .nodelay(true)
            );
            
            // CRITICAL: DNS resolution must happen BEFORE WebSocket layer
            // so original DNS name is preserved for TLS hostname verification
            let dns_tcp = match libp2p::dns::tokio::Transport::system(tcp_transport) {
                Ok(dns) => dns,
                Err(e) => {
                    error!("Failed to create DNS resolver for TCP: {}", e);
                    return Err(e.into());
                }
            };
            
            // Then wrap it with WebSocket 
            // Now DNS->TCP->WS ensures hostname is preserved for TLS validation
            libp2p::websocket::WsConfig::new(dns_tcp)
                .upgrade(Version::V1Lazy)
                .authenticate(noise::Config::new(&local_key)?)
                .multiplex(libp2p::yamux::Config::default())
                .timeout(Duration::from_secs(20))
                .boxed()
        };

        // WebRTC Transport
        let webrtc_cert = WebRtcCertificate::generate(&mut rand::thread_rng())?;
        let webrtc_transport = WebRtcTransport::new(local_key.clone(), webrtc_cert)
            // No extra mapping needed, the default is fine
            .boxed();

        // WebTransport Transport
        let webtransport_config = WebTransportConfig::new(&local_key);
        let webtransport = WebTransport::new(webtransport_config);

        // Combine transports
        let combined_transport = tcp_transport
            .or_transport(ws_transport)
            .or_transport(webrtc_transport)
            .or_transport(webtransport)
            .map(|either_output, _| {
                // Map the output of the combined transports to (PeerId, StreamMuxerBox)
                match either_output {
                    Either::Left(Either::Left(Either::Left(tcp_conn))) => tcp_conn,
                    Either::Left(Either::Left(Either::Right(ws_conn))) => ws_conn,
                    Either::Left(Either::Right(webrtc_conn)) => (webrtc_conn.0, StreamMuxerBox::new(webrtc_conn.1)),
                    // Map WebTransport connection to StreamMuxerBox
                    Either::Right(webtransport_conn) => (webtransport_conn.0, StreamMuxerBox::new(webtransport_conn.1)),
                }
            })
            .boxed();

        // No need for a final DNS layer - it's already included in the individual transports
        combined_transport
    };

    // Create the behaviour
    let behaviour = {
        // Configure GossipSub with parameters similar to the TypeScript implementation
        let gossipsub_config = libp2p::gossipsub::ConfigBuilder::default()
            .max_transmit_size(1024 * 1024) // 1MB max message size
            .heartbeat_interval(Duration::from_secs(20))
            .validation_mode(ValidationMode::Permissive) // Allow all messages
            .mesh_outbound_min(2) // Ensure outbound connections for proper relay
            .mesh_n_low(2) // Lower threshold for mesh maintenance
            .allow_self_origin(true) // Allow receiving our own messages
            .duplicate_cache_time(Duration::from_secs(1)) // Shorter duplicate cache to avoid missing messages
            .validate_messages() // Enable message validation
            .build()
            .expect("Valid GossipSub configuration");
        
        // Create parameters similar to TypeScript version
        let mut gossipsub = Gossipsub::new(
            MessageAuthenticity::Signed(local_key.clone()),
            gossipsub_config,
        )?;
        
        // Subscribe to topics if provided
        if let Some(topics_str) = &pubsub_topics {
            for name in topics_str.split(',') {
                let topic = Sha256Topic::new(name.trim());
                if gossipsub.subscribe(&topic).is_err() {
                     error!("Failed to subscribe to topic: {}", name.trim());
                } else {
                     info!("Peer {} subscribed to topic: {}", local_peer_id, name.trim());
                }
            }
        }

        // Configure the relay behaviour - add unlimited reservations like in TypeScript
        let relay_config = relay::Config {
             max_circuits: 32,
             max_reservations: usize::MAX, // Set to unlimited like TypeScript
             reservation_duration: Duration::from_secs(60 * 60), // Default
             max_circuit_duration: Duration::from_secs(2 * 60),
             max_circuit_bytes: 1 << 17, // 128 KiB
             max_reservations_per_peer: 1,
             max_circuits_per_peer: 16,
             circuit_src_rate_limiters: Default::default(),
             reservation_rate_limiters: Default::default(),
        };

        // Configure AutoNAT
        let autonat_config = autonat::Config { 
            // Keep defaults, or customize here
            ..Default::default()
        };

        RelayBehaviour {
           relay: relay::Behaviour::new(local_peer_id, relay_config),
           ping: ping::Behaviour::new(ping::Config::new()),
           identify: identify::Behaviour::new(identify_config),
           pubsub: gossipsub,
           dcutr: dcutr::Behaviour::new(local_peer_id),
           autonat: autonat::Behaviour::new(local_peer_id, autonat_config),
       }
    };

    // Build the Swarm
    let swarm = SwarmBuilder::with_existing_identity(local_key)
        .with_tokio()
        .with_other_transport(|_| Ok(transport))? // Pass the built transport
        .with_behaviour(|_| Ok(behaviour))?
        .with_swarm_config(|c| c
            .with_idle_connection_timeout(Duration::from_secs(60))
            .with_max_negotiating_inbound_streams(10000)
        )
        .build();

    Ok(swarm)
}

// Function to test connection to a specific relay hostname
async fn test_dns_relay_connection(hostname: &str) -> Result<(), Box<dyn Error>> {
    info!("Testing connection to relay at {}", hostname);
    
    // Make sure we have a domain set in the environment
    if env::var("DOMAINE").is_err() {
        info!("Setting DOMAINE to {} for this test", hostname);
        env::set_var("DOMAINE", hostname);
    }
    
    // Generate a new key for this test
    let local_key = Keypair::generate_ed25519();
    let local_peer_id = PeerId::from(local_key.public());
    info!("Test client peer ID: {}", local_peer_id);
    
    // Build a minimal swarm focused on just the connection test
    let mut swarm = build_swarm(local_key, None).await?;
    
    // CRITICAL: Create relay address explicitly using dns4 protocol
    // This ensures DNS lookup happens at the TLS layer rather than at IP layer
    let relay_addr = format!("/dns4/{}/tcp/443/wss", hostname).parse::<Multiaddr>()?;
    info!("Attempting to connect to {}", relay_addr);
    
    // IMPORTANT: Set external address for ourselves with the DNS name too
    let our_external_addr = format!("/dns4/{}/tcp/443/wss/p2p/{}", hostname, swarm.local_peer_id()).parse::<Multiaddr>()?;
    swarm.add_external_address(our_external_addr.clone());
    info!("Added external address with domain: {}", our_external_addr);
    
    // Attempt the connection
    match swarm.dial(relay_addr.clone()) {
        Ok(_) => info!("Initiated connection to {}", relay_addr),
        Err(e) => {
            error!("Failed to dial {}: {}", relay_addr, e);
            return Err(e.into());
        }
    }
    
    // Check for successful connection
    let mut connected = false;
    let mut timeout = tokio::time::interval(Duration::from_secs(1));
    let start_time = std::time::Instant::now();
    let timeout_duration = Duration::from_secs(10);
    
    while !connected && start_time.elapsed() < timeout_duration {
        tokio::select! {
            _ = timeout.tick() => {
                // Check if we're connected to any peers
                let connected_peer_count = swarm.connected_peers().count();
                if connected_peer_count > 0 {
                    info!("Connected to {} peers", connected_peer_count);
                    connected = true;
                    break;
                }
            },
            event = swarm.select_next_some() => {
                match event {
                    SwarmEvent::ConnectionEstablished { peer_id, .. } => {
                        info!("Successfully connected to {}", peer_id);
                        connected = true;
                    },
                    SwarmEvent::OutgoingConnectionError { peer_id, error, .. } => {
                        // Log the full error for better debugging
                        error!("Connection error to {:?}: {}", peer_id, error);
                        if error.to_string().contains("certificate") {
                            error!("TLS certificate validation error - this indicates the hostname isn't being preserved");
                        }
                        return Err(format!("Connection error: {}", error).into());
                    },
                    _ => {}
                }
            }
        }
    }
    
    if connected {
        info!("✅ Successfully connected to relay at {}", hostname);
        Ok(())
    } else {
        let error_msg = format!("❌ Failed to connect to relay at {} within {} seconds", 
                               hostname, timeout_duration.as_secs());
        error!("{}", error_msg);
        Err(error_msg.into())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Load environment variables from .env file, ignore errors (e.g., file not found)
    dotenv().ok();
    env_logger::builder().filter_level(LevelFilter::Info).init();

    // Check if certificate verification should be disabled (for development/testing only!)
    let disable_cert_verification = env::var("DISABLE_CERT_VERIFICATION")
        .map(|val| val.to_lowercase() == "true")
        .unwrap_or(false);
    
    // Check if we're just testing a connection to a specific relay
    let test_relay = env::var("TEST_RELAY").ok();
    if let Some(hostname) = test_relay {
        info!("Running in relay test mode for hostname: {}", hostname);
        return test_dns_relay_connection(&hostname).await;
    }
    
    if disable_cert_verification {
        warn!("⚠️ SECURITY WARNING: Certificate verification is DISABLED. This is insecure and should only be used for development/testing!");
        // Set environment variable for rustls to disable certificate verification
        env::set_var("RUSTLS_DANGER_DISABLE_CERTIFICATE_VERIFICATION", "1");
    }

    info!("Starting Rust libp2p relay node...");

    // --- Configuration Loading ---
    let domain_name = env::var("DOMAINE").ok();
    let pubsub_topics = env::var("RELAY_PUBSUB_PEER_DISCOVERY_TOPICS").ok();
    let bootstrap_peers_str = env::var("RELAY_BOOTSTRAP_LIST").ok(); // Load bootstrap list

    // Log the loaded optional config
    if let Some(domain) = &domain_name {
        info!("Using domain: {}", domain);
    } else {
        info!("No DOMAINE environment variable found.");
    }
    if let Some(topics) = &pubsub_topics {
        info!("PubSub discovery topics configured: {}", topics);
        // TODO: Use these topics when pubsub is implemented
    } else {
        info!("No RELAY_PUBSUB_PEER_DISCOVERY_TOPICS environment variable found.");
    }
    if let Some(peers) = &bootstrap_peers_str {
        info!("Bootstrap peers configured: {}", peers);
    } else {
        info!("No RELAY_BOOTSTRAP_LIST environment variable found.");
    }

    // Create shared state for listening addresses
    let listening_addresses: ListeningAddresses = Arc::new(Mutex::new(Vec::new()));

    // Create keypair for the node's identity, handling potential errors
    let local_key = match load_keypair_from_env() {
        Ok(kp) => kp,
        Err(e) => {
            // Log the specific error and exit
            error!("Fatal error loading keypair: {}", e);
            return Err(e); // Propagate the error to exit main
        }
    };

    // If this was a newly generated keypair, save it to .env file (like TypeScript implementation)
    if env::var("CLEF_PRIVEE_RELAI").is_err() {
        match local_key.to_protobuf_encoding() {
            Ok(key_bytes) => {
                // Encode to base64
                let key_b64 = base64_engine.encode(&key_bytes);
                
                // Append to .env file
                if let Err(e) = fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(".env")
                    .and_then(|mut file| writeln!(file, "\nCLEF_PRIVEE_RELAI={}", key_b64)) 
                {
                    warn!("Failed to save generated keypair to .env file: {}", e);
                } else {
                    info!("New keypair saved to .env file for future use.");
                }
            },
            Err(e) => warn!("Failed to encode keypair for saving to .env: {}", e),
        }
    }

    let local_peer_id = PeerId::from(local_key.public());
    info!("Local peer ID: {}", local_peer_id);

    // Build the Swarm
    let mut swarm = build_swarm(local_key.clone(), pubsub_topics).await?;
    let mut relay_reqs: HashMap<PeerId, HashSet<String>> = HashMap::new();
    let always_relay: Vec<String> = vec!["réseau-constellation".to_string()];

    // Explicitly subscribe to always_relay topics
    for topic_name in &always_relay {
        let topic = Sha256Topic::new(topic_name.clone());
        if let Err(e) = swarm.behaviour_mut().pubsub.subscribe(&topic) {
            error!("Failed to subscribe to initial always_relay topic {}: {}", topic_name, e);
        } else {
            info!("Initially subscribed to always_relay topic: {}", topic_name);
        }
    }

    // Define listening addresses
    // Listen on all interfaces for TCP (port 0 asks OS for a free port)
    let listen_addr_tcp = "/ip4/0.0.0.0/tcp/0".parse::<Multiaddr>()?;
    swarm.listen_on(listen_addr_tcp)?;

    // Listen on all interfaces for WebSocket on port 12345
    let listen_addr_ws = "/ip4/0.0.0.0/tcp/12345/ws".parse::<Multiaddr>()?;
    swarm.listen_on(listen_addr_ws)?;

    // Also listen on WebRTC multiaddr for direct peer connections
    match swarm.listen_on("/ip4/0.0.0.0/udp/0/webrtc-direct".parse()?) {
        Ok(listener_id) => info!("Listening on WebRTC-direct with listener ID: {:?}", listener_id),
        Err(e) => warn!("Failed to listen on WebRTC-direct: {}", e),
    }
    
    // Only add explicit WebRTC IP-based address when no domain is provided
    if domain_name.is_none() {
        // Add explicit WebRTC address for our peer ID (helps with discovery)
        let webrtc_addr: Multiaddr = format!("/ip4/0.0.0.0/udp/0/webrtc-direct/p2p/{}", local_peer_id).parse()?;
        swarm.add_external_address(webrtc_addr.clone());
        info!("Added external WebRTC-direct address: {}", webrtc_addr);
    }

    // If a domain name is provided, add external addresses for Nginx proxying
    if let Some(domain) = &domain_name {
        // Add WSS over 443 address (for secure WebSocket connections through Nginx)
        let wss_addr = format!("/dns4/{}/tcp/443/wss/p2p/{}", domain, local_peer_id).parse::<Multiaddr>();
        match wss_addr {
            Ok(addr) => {
                // Advertise the secure WebSocket address
                swarm.add_external_address(addr.clone());
                info!("Advertising WSS address: {}", addr);
            }
            Err(e) => {
                error!("Failed to parse WSS address from domain {}: {}", domain, e);
            }
        }

        // Add WS over 80 address (for plain WebSocket connections through Nginx)
        let ws_addr = format!("/dns4/{}/tcp/80/ws/p2p/{}", domain, local_peer_id).parse::<Multiaddr>();
        match ws_addr {
            Ok(addr) => {
                // Advertise the plain WebSocket address
                swarm.add_external_address(addr.clone());
                info!("Advertising WS address: {}", addr);
            }
            Err(e) => {
                error!("Failed to parse WS address from domain {}: {}", domain, e);
            }
        }
        
        // Also add WebRTC address with domain
        let webrtc_dns_addr = format!("/dns4/{}/udp/443/webrtc-direct/p2p/{}", domain, local_peer_id).parse::<Multiaddr>();
        match webrtc_dns_addr {
            Ok(addr) => {
                swarm.add_external_address(addr.clone());
                info!("Advertising WebRTC-direct DNS address: {}", addr);
            }
            Err(e) => {
                error!("Failed to parse WebRTC-direct DNS address from domain {}: {}", domain, e);
            }
        }
    } else {
        info!("No domain name provided. Only advertising direct IP-based addresses.");
    }

    // --- Bootstrap Dialing ---
    // Parse bootstrap peers AFTER starting listeners
    let bootstrap_peers: Vec<Multiaddr> = if let Some(peers_str) = bootstrap_peers_str {
        peers_str.split(',')
            .filter_map(|s| {
                match Multiaddr::from_str(s.trim()) {
                    Ok(addr) => {
                        info!("Parsed bootstrap address: {}", addr);
                        Some(addr)
                    },
                    Err(e) => {
                        error!("Failed to parse bootstrap address '{}': {}", s.trim(), e);
                        None
                    }
                }
            })
            .collect()
    } else {
        Vec::new() // No bootstrap peers if var not set
    };

    // Dial bootstrap peers
    if !bootstrap_peers.is_empty() {
        info!("Dialing {} bootstrap peers...", bootstrap_peers.len());
        
        // Set environment variable to preserve DNS names for WebSockets
        env::set_var("LIBP2P_WEBSOCKET_PRESERVE_DNS", "true");
        
        for addr in bootstrap_peers {
            // Log whether the address is DNS-based or IP-based
            let uses_dns = addr.to_string().contains("/dns");
            
            if uses_dns {
                info!("Dialing DNS-based bootstrap peer: {}", addr);
            } else {
                info!("Dialing IP-based bootstrap peer: {}", addr);
            }
            
            // For maximum connectivity, always dial using the original address format
            match swarm.dial(addr.clone()) {
                Ok(_) => info!("Initiated dial to bootstrap peer: {}", addr),
                Err(e) => error!("Failed to dial bootstrap peer {}: {}", addr, e),
            }
        }
    } else {
        info!("No valid bootstrap peers to dial.");
    }
    // Add WebRTC listen address if not added already
    // swarm.listen_on("/ip4/0.0.0.0/udp/0/webrtc-direct".parse()?)?; // Example, adjust as needed

    // Clone Arc for the web server task
    let server_listening_addresses = listening_addresses.clone();

    // Spawn the web server task
    tokio::spawn(async move {
        info!("Starting web server on port 8000...");

        // Route for serving index.html at the root
        let index_html_content = include_str!("index.html"); // Embed index.html content
        let index_route = warp::path::end() // Match the root path "/"
            .map(move || warp::reply::html(index_html_content));

        // Route for serving listening addresses at /adresses
        let addresses_route = warp::path("adresses")
            .and(warp::get()) // Match GET requests
            .map(move || {
                let addrs = server_listening_addresses.lock();
                // Filter out loopback addresses like the JS example if desired
                // let public_addrs: Vec<_> = addrs.iter()
                //     .filter(|a| !a.to_string().starts_with("/ip4/127.0.0.1"))
                //     .cloned()
                //     .collect();
                // warp::reply::json(&public_addrs) // Use this line to filter
                warp::reply::json(&*addrs) // Serve all addresses for now
            });

        let routes = index_route.or(addresses_route);

        warp::serve(routes)
            .run(([0, 0, 0, 0], 8000)) // Listen on all interfaces, port 8000
            .await;
    });

    // Create a periodic timer for status logging
    let mut status_interval = interval(Duration::from_secs(30));
    // Initial status log to avoid waiting for first interval tick
    {
        let info = swarm.network_info();
        let counters = info.connection_counters();
        let peers: Vec<_> = swarm.connected_peers().cloned().collect();
        info!(
            "Initial Status: Connected Peers: {} {:?}, Connections: {{ pending_in: {}, pending_out: {}, established_in: {}, established_out: {}, established: {} }}",
            peers.len(),
            peers,
            counters.num_pending_incoming(),
            counters.num_pending_outgoing(),
            counters.num_established_incoming(),
            counters.num_established_outgoing(),
            counters.num_established()
        );
    }

    // Main event loop
    loop {
        tokio::select! {
            // Branch for the status interval timer
            _ = status_interval.tick() => {
                let info = swarm.network_info();
                let counters = info.connection_counters();
                let peers: Vec<_> = swarm.connected_peers().cloned().collect();
                info!(
                    "Status: Connected Peers: {} {:?}, Connections: {{ pending_in: {}, pending_out: {}, established_in: {}, established_out: {}, established: {} }}",
                    peers.len(),
                    peers,
                    counters.num_pending_incoming(),
                    counters.num_pending_outgoing(),
                    counters.num_established_incoming(),
                    counters.num_established_outgoing(),
                    counters.num_established()
                );
            }
            event = swarm.select_next_some() => {
                let addresses_for_event = listening_addresses.clone();
                match event {
                    SwarmEvent::NewListenAddr { address, .. } => {
                        info!("Local node listening on: {}", address);
                        // Add the new address to our shared list
                        addresses_for_event.lock().push(address.clone());
                    }
                     SwarmEvent::ExpiredListenAddr { address, .. } => {
                        info!("Local node stopped listening on: {}", address);
                        // Remove the expired address from our shared list
                        addresses_for_event.lock().retain(|a| *a != address);
                    }
                    SwarmEvent::Behaviour(RelayEvent::Identify(identify_event)) => {
                        match identify_event {
                            identify::Event::Received { peer_id, info, .. } => {
                                info!("Identified Peer: {} with agent version: {}", peer_id, info.agent_version);
                                for addr in info.listen_addrs {
                                    swarm.add_external_address(addr.clone());
                                    info!("Added external address from Identify: {}", addr);
                                }
                            }
                            _ => info!("Other Identify event: {:?}", identify_event),
                        }
                    }
                    SwarmEvent::Behaviour(RelayEvent::Ping(ping_event)) => {
                        info!("Ping event: {:?}", ping_event);
                    }
                    SwarmEvent::Behaviour(RelayEvent::Relay(relay_event)) => {
                        match relay_event {
                            relay::Event::ReservationReqAccepted { src_peer_id, renewed, .. } => {
                                if renewed {
                                    info!("Relay reservation renewed for client: {}", src_peer_id);
                                } else {
                                    info!("Client {} successfully reserved relay hop", src_peer_id);
                                }
                            }
                            relay::Event::ReservationTimedOut { src_peer_id, .. } => {
                                warn!("Relay reservation timed out for client: {}", src_peer_id);
                            }
                            _ => {
                                info!("Other Relay event: {:?}", relay_event);
                            }
                        }
                    }
                    SwarmEvent::Behaviour(RelayEvent::Pubsub(pubsub_event)) => {
                        match pubsub_event {
                            GossipsubEvent::Subscribed { peer_id, topic } => {
                                info!("Peer {} subscribed to topic: {}", peer_id, topic);
                                let topic_name = topic.to_string();

                                // Recreate the Topic type from the hash/name for subscribe call
                                let topic_to_subscribe = Sha256Topic::new(topic_name.clone());

                                // Track the peer's subscription
                                let peer_topics = relay_reqs.entry(peer_id).or_default();
                                peer_topics.insert(topic_name.clone());

                                // Check if the relay needs to subscribe (if it wasn't already)
                                // We assume the relay should be subscribed if at least one peer needs it OR it's an always_relay topic.
                                // Gossipsub::subscribe is idempotent, so calling it again is safe.
                                if let Err(e) = swarm.behaviour_mut().pubsub.subscribe(&topic_to_subscribe) {
                                    error!("Error subscribing relay to topic {} after peer subscription: {}", topic_name, e);
                                } else {
                                     // Optional: Add log if needed, but subscribe is idempotent.
                                     // info!("Ensured relay is subscribed to topic: {}", topic_name);
                                }
                            }
                            GossipsubEvent::Unsubscribed { peer_id, topic } => {
                                info!("Peer {} unsubscribed from topic: {}", peer_id, topic);
                                let topic_name = topic.to_string();

                                // Recreate the Topic type from the hash/name for unsubscribe call
                                let topic_to_unsubscribe = Sha256Topic::new(topic_name.clone());

                                // Remove the topic from the peer's tracked subscriptions
                                let mut remove_peer_entry = false;
                                if let Some(peer_topics) = relay_reqs.get_mut(&peer_id) {
                                    peer_topics.remove(&topic_name);
                                    if peer_topics.is_empty() {
                                        remove_peer_entry = true;
                                    }
                                }
                                if remove_peer_entry {
                                    relay_reqs.remove(&peer_id);
                                }

                                // Check if the relay can unsubscribe from this topic
                                let still_needed = relay_reqs.values().any(|topics| topics.contains(&topic_name))
                                                   || always_relay.contains(&topic_name);

                                if !still_needed {
                                    info!("No other peer needs topic {} and it's not always_relay. Unsubscribing relay.", topic_name);
                                    // Use boolean check for unsubscribe result
                                    if !swarm.behaviour_mut().pubsub.unsubscribe(&topic_to_unsubscribe) {
                                        // Log if unsubscribe returned false (e.g., wasn't subscribed) - usually benign
                                        warn!("Relay unsubscribe call for topic {} returned false (might have been already unsubscribed).", topic_name);
                                    } else {
                                        info!("Relay unsubscribed from topic: {}", topic_name);
                                    }
                                } else {
                                    info!("Relay keeps subscription to topic {} after peer disconnect (needed by others or always_relay).", topic_name);
                                }
                            }
                            GossipsubEvent::Message { message, .. } => {
                                info!(
                                    "Received PubSub message: From={:?}, Topic={}, Data='{}'",
                                    message.source,
                                    message.topic,
                                    String::from_utf8_lossy(&message.data)
                                );
                                
                                // The message is automatically relayed by GossipSub when configured properly
                                // Just log that we're handling it for debugging purposes
                                info!("Handling message for topic {} - will be relayed to all subscribed peers", message.topic);
                            }
                            _ => {
                                info!("Other PubSub event: {:?}", pubsub_event);
                            }
                        }
                    }
                    SwarmEvent::Behaviour(RelayEvent::Dcutr(event)) => {
                        match event.result {
                            Ok(connection_id) => {
                                info!("DCUtR connection successful with peer {}, connection ID: {:?}", 
                                      event.remote_peer_id, connection_id);
                            },
                            Err(error) => {
                                warn!("DCUtR failed with peer {}: {:?}", 
                                      event.remote_peer_id, error);
                            }
                        }
                    }
                    SwarmEvent::Behaviour(RelayEvent::AutoNat(autonat_event)) => {
                        match autonat_event {
                            autonat::Event::StatusChanged { old, new } => {
                                info!("AutoNAT status changed from {:?} to {:?}", old, new);
                            }
                            autonat::Event::InboundProbe(e) => {
                                info!("AutoNAT inbound probe event: {:?}", e); 
                            }
                             autonat::Event::OutboundProbe(e) => {
                                info!("AutoNAT outbound probe event: {:?}", e); 
                            }
                        }
                    }
                    SwarmEvent::ConnectionEstablished { peer_id, endpoint, num_established, concurrent_dial_errors, established_in, .. } => {
                        info!(
                            "Connection established: peer={}, endpoint={:?}, num_established={}, concurrent_dials_errors={:?}, established_in={:?}",
                            peer_id, endpoint.get_remote_address(), num_established, concurrent_dial_errors.map(|n| n.len()), established_in
                        );
                        let connected_peers_count = swarm.connected_peers().count();
                        info!("Connected peers count after establishment: {}", connected_peers_count);
                    }
                     SwarmEvent::ConnectionClosed { peer_id, connection_id, endpoint, num_established, cause, .. } => {
                        info!(
                            "Connection closed: peer={}, connection_id={:?}, endpoint={:?}, num_established={}, reason={:?}",
                            peer_id, connection_id, endpoint.get_remote_address(), num_established, cause
                        );
                         let connected_peers_count = swarm.connected_peers().count();
                        info!("Connected peers count after closure: {}", connected_peers_count);

                        // When a peer disconnects, check if we can unsubscribe the relay from topics they were the *last* user of.
                        if let Some(disconnected_peer_topics) = relay_reqs.remove(&peer_id) {
                             info!("Removed tracked subscriptions for disconnected peer: {}", peer_id);

                             for topic_name in disconnected_peer_topics {
                                 // Check if the topic is still needed by any REMAINING peer or is an always_relay topic
                                let still_needed = relay_reqs.values().any(|topics| topics.contains(&topic_name))
                                                   || always_relay.contains(&topic_name);

                                if !still_needed {
                                     info!("Disconnected peer {} was the last user of topic {}. Unsubscribing relay.", peer_id, topic_name);
                                     let topic = Sha256Topic::new(topic_name.clone());
                                     // Use boolean check for unsubscribe result
                                     if !swarm.behaviour_mut().pubsub.unsubscribe(&topic) {
                                         warn!("Relay unsubscribe call for topic {} after disconnect returned false.", topic_name);
                                     } else {
                                         info!("Relay unsubscribed from topic {} after peer disconnect", topic_name);
                                     }
                                 } else {
                                     info!("Relay keeps subscription to topic {} after peer disconnect (needed by others or always_relay).", topic_name);
                                 }
                             }
                         } else {
                             info!("No tracked subscriptions found for disconnected peer: {}", peer_id);
                         }
                    }
                    // Added `..` to ignore unmentioned fields like connection_id
                    SwarmEvent::IncomingConnection { local_addr, send_back_addr, .. } => {
                        info!("Incoming connection from {} to {}", send_back_addr, local_addr);
                    }
                    // Added `..` to ignore unmentioned fields like connection_id
                    SwarmEvent::IncomingConnectionError { local_addr, send_back_addr, error, .. } => {
                        error!("Incoming connection error from {} to {}: {}", send_back_addr, local_addr, error);
                    }
                    SwarmEvent::OutgoingConnectionError { peer_id, error, .. } => {
                        error!("Outgoing connection error to {:?}: {}", peer_id, error);
                    }
                    SwarmEvent::ListenerError { listener_id, error } => {
                        error!("Listener error for {:?}: {}", listener_id, error);
                    }
                     SwarmEvent::ListenerClosed { listener_id, reason, .. } => {
                        info!("Listener {:?} closed: {:?}", listener_id, reason);
                    }
                    SwarmEvent::Dialing { peer_id, connection_id } => {
                        // Dialing event now includes peer_id which might be None if dialing an address without knowing the peer ID yet.
                        info!("Dialing: peer={:?}, connection_id={:?}", peer_id, connection_id);
                    }
                    _ => {
                        // Handle other swarm events as needed
                        // info!("Unhandled Swarm Event: {:?}", event);
                    }
                }
            }
        }
    }
}
