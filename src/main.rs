use futures::stream::StreamExt;
use futures::future::Either;
use libp2p::{
    core::transport::upgrade::Version, // Added back Version import
    identity::{Keypair},
    noise, ping, relay, identify,
    swarm::{NetworkBehaviour, SwarmEvent},
    /* Removed unused tcp import */ Multiaddr, PeerId, SwarmBuilder, Transport,
    /* Removed unused dns import */
    // Removed unused websocket import, access via libp2p::websocket
};
use std::{env, error::Error, time::Duration}; // Added env for environment variables
use std::collections::{HashMap, HashSet}; // Added for PubSub relayer state
use std::sync::Arc; // Added Arc
use parking_lot::Mutex;
use tokio::time::interval;
use log::{info, error, warn, LevelFilter};
use warp::Filter;
use dotenvy::dotenv; // Added dotenvy import
use libp2p::dns::tokio::Transport as TokioDnsConfig;
use base64::{engine::general_purpose::{STANDARD as base64_engine, STANDARD_NO_PAD}, Engine as _}; // Added base64 imports
use libp2p::gossipsub::{Behaviour as Gossipsub, Config as GossipsubConfig, MessageAuthenticity, Sha256Topic, Event as GossipsubEvent}; // Updated PubSub imports
use prost::Message; // Import prost::Message trait
use bytes::Bytes; // Import bytes::Bytes

// Include the Rust code generated by prost from identity.proto
// This module will contain KeyType enum and PrivateKey struct
pub mod identity_proto {
    include!(concat!(env!("OUT_DIR"), "/relay.identity.proto.rs"));
}

// Define the network behaviour combining multiple protocols
#[derive(NetworkBehaviour)]
// The `relay::Behaviour` emits `void::Void`, so we don't need a custom event for it.
// The overall event type `RelayEvent` will be generated by the derive macro.
#[behaviour(to_swarm = "RelayEvent")]
struct RelayBehaviour {
    // Note: relay::Behaviour<RelayReservation> is the full type, but Behaviour often suffices.
    relay: relay::Behaviour,
    ping: ping::Behaviour,
    identify: identify::Behaviour,
    pubsub: Gossipsub, // Added gossipsub behaviour
}

// Define the custom event type that the behaviour emits to the Swarm.
// The derive macro automatically generates variants for behaviours that emit events.
// Since relay::Behaviour emits void::Void, we only need variants for Ping and Identify.
#[derive(Debug)]
enum RelayEvent {
    Ping(ping::Event),
    Identify(identify::Event),
    Relay(relay::Event), // Added Relay variant
    Pubsub(GossipsubEvent), // Added PubSub variant
}

// From implementations are needed for all variants the derive macro maps.

impl From<relay::Event> for RelayEvent {
    fn from(event: relay::Event) -> Self {
        RelayEvent::Relay(event)
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use base64::engine::general_purpose::STANDARD as base64_engine;
    use base64::Engine;
    // Removed duplicate super import
    use libp2p::{
        ping, identify, // Removed relay import as it's not used directly in tests now
        identity::Keypair,
        PeerId, Multiaddr, StreamProtocol,
        swarm::ConnectionId,
        // Removed relay::client import
    };
    use std::num::NonZeroU32; // Import NonZeroU32
    use libp2p::gossipsub::{ValidationMode, ConfigBuilder}; // Allow permissive validation for Anonymous pubsub in tests

    // Helper to create a dummy PeerId for testing
    fn dummy_peer_id() -> PeerId {
        PeerId::from(Keypair::generate_ed25519().public())
    }

    // Helper to create a dummy Multiaddr for testing
    fn dummy_multiaddr() -> Multiaddr {
        "/ip4/127.0.0.1/tcp/0".parse().unwrap()
    }

    // Removed test_from_relay_client_event as relay::Behaviour no longer emits these events directly
    // in a way that maps to our RelayEvent enum.

    #[test]
    fn test_from_ping_event() {
        let peer_id = dummy_peer_id();
        let ping_event = ping::Event {
            peer: peer_id,
            connection: ConnectionId::new_unchecked(0), // Use new_unchecked for simplicity in test
            // Ping result is now directly Result<Duration, Failure>
            result: Result::Ok(Duration::from_millis(10)),
        };
        let event: RelayEvent = ping_event.into();
        assert!(matches!(event, RelayEvent::Ping(ping::Event { result: Ok(_), .. }))); // Adjusted match slightly
    }

    #[test]
    fn test_from_identify_event() {
        let peer_id = dummy_peer_id();
        let public_key = Keypair::generate_ed25519().public();
        let identify_event = identify::Event::Received {
            peer_id,
            info: identify::Info {
                public_key,
                protocol_version: "test/1.0".to_string(),
                agent_version: "test-agent/0.1".to_string(),
                listen_addrs: vec![dummy_multiaddr()],
                // Use StreamProtocol::new for protocol names
                protocols: vec![StreamProtocol::new("/test/1")],
                observed_addr: dummy_multiaddr(),
            },
            connection_id: ConnectionId::new_unchecked(0), // Added missing field
        };
        let event: RelayEvent = identify_event.into();
        assert!(matches!(event, RelayEvent::Identify(identify::Event::Received { .. })));
    }

    // Example test for a SwarmEvent pattern match (demonstrates structure, not a real unit test)
    // This kind of test is more suited for integration tests where a real Swarm exists.
    #[test]
    fn test_swarm_event_match_structure() {
        let peer_id = dummy_peer_id();
        let dummy_endpoint = libp2p::core::ConnectedPoint::Listener {
             local_addr: dummy_multiaddr(),
             send_back_addr: dummy_multiaddr(),
        };
        // Correct the type annotation for SwarmEvent (only one generic argument)
        let event: SwarmEvent<RelayEvent> = SwarmEvent::ConnectionEstablished {
            peer_id,
            connection_id: ConnectionId::new_unchecked(0),
            endpoint: dummy_endpoint,
            // Use NonZeroU32 for num_established
            num_established: NonZeroU32::new(1).unwrap(),
            concurrent_dial_errors: None,
            established_in: Duration::from_secs(0),
        };

        match event {
             SwarmEvent::ConnectionEstablished { peer_id: p, endpoint: e, num_established, .. } => {
                 assert_eq!(p, peer_id);
                 assert!(matches!(e, libp2p::core::ConnectedPoint::Listener{..}));
                 // Compare with the correct NonZeroU32 value
                 assert_eq!(num_established, NonZeroU32::new(1).unwrap());
             },
             _ => panic!("Event did not match expected pattern"),
        }
    }

   #[test]
   fn test_relay_behaviour_construction() {
       let local_key = Keypair::generate_ed25519();
       let local_peer_id = PeerId::from(local_key.public());
       let identify_config = identify::Config::new(
           "/test-protocol/1.0".to_string(),
           local_key.public(),
       );

       // Prefix with underscore to silence unused variable warning
       let _behaviour = RelayBehaviour {
           relay: relay::Behaviour::new(local_peer_id, Default::default()),
           ping: ping::Behaviour::new(ping::Config::new()),
           identify: identify::Behaviour::new(identify_config.clone()), // Clone config for assertion
           pubsub: Gossipsub::new(
               MessageAuthenticity::Anonymous,
               ConfigBuilder::from(GossipsubConfig::default()).validation_mode(ValidationMode::Permissive).build().unwrap()
           ).unwrap(),
       };

       // Basic assertion to ensure the behaviour fields are populated.
       // More detailed checks might involve inspecting behaviour states if APIs allow,
       // but often just checking construction is sufficient for a unit test.
       // Cannot directly access config from behaviour, rely on test_identify_config_creation
       // assert_eq!(behaviour.identify.config().protocol_version, identify_config.protocol_version);

       // Ping and Relay behaviours don't expose simple config getters in the same way easily.
       // We rely on the type system and successful construction.
       // Dummy assertion to ensure the test runs and compiles.
       assert!(true);
   }

   #[test]
   fn test_identify_config_creation() {
       let local_key = Keypair::generate_ed25519();
       let public_key = local_key.public();
       let protocol_version = "/test-identify/1.0".to_string();
       let agent_version = "test-agent/0.1".to_string();

       let config = identify::Config::new(
           protocol_version.clone(),
           public_key.clone(),
       )
       .with_agent_version(agent_version.clone());

       assert_eq!(config.protocol_version(), protocol_version);
       // Field name changed from public_key to local_public_key
       assert_eq!(config.local_public_key(), &public_key);
       assert_eq!(config.agent_version(), agent_version);
       // initial_delay field removed or changed, remove assertion
       // assert_eq!(config.initial_delay, Duration::from_millis(500));
       // Check default interval instead (adjust if libp2p defaults change)
       assert_eq!(config.interval(), Duration::from_secs(5 * 60));
   }

   use super::identity_proto; // Import generated proto module
   use prost::Message; // Import Message trait for encoding test key
   // Removed unused bytes::Bytes import

   #[test]
   fn test_clef_privée_relai_env_key_loading_custom_protobuf() {
       // Generate a keypair to get raw secret bytes
       let original_keypair = Keypair::generate_ed25519();
       let expected_public_key = original_keypair.public(); // For comparison later

       // Extract the raw 32-byte secret key
       // This is tricky as Keypair doesn't directly expose the secret bytes.
       // We need to extract them from the standard protobuf encoding.
       let proto_bytes = original_keypair.to_protobuf_encoding().unwrap();
       // The secret key is typically bytes 4 to 36 in the standard encoding.
       let secret_slice = &proto_bytes[4..36];
       // Convert the slice to a fixed-size array [u8; 32]
       let secret_array: [u8; 32] = secret_slice.try_into()
           .expect("Slice from protobuf encoding should be 32 bytes for Ed25519");

       // Now use the fixed-size array with ed25519_dalek if needed, or directly below.
       // let dalek_signing_key = ed25519_dalek::SigningKey::from_bytes(&secret_array);
       // let secret_bytes_32 = dalek_signing_key.to_bytes(); // This is just secret_array again

       // Create the custom protobuf message
       let private_key_message = identity_proto::PrivateKey {
           r#type: identity_proto::KeyType::Ed25519 as i32,
           // Convert the fixed-size array (or Bytes) to Vec<u8> as expected by the struct field
           data: secret_array.to_vec(), // Use the 32 raw secret bytes as a Vec<u8>
       };

       // Encode this custom message to protobuf bytes
       let custom_protobuf_bytes = private_key_message.encode_to_vec();

       // Base64 encode these custom protobuf bytes
       let key_b64 = base64_engine.encode(&custom_protobuf_bytes);
       std::env::set_var("CLEF_PRIVEE_RELAI", &key_b64);

       // --- Actually call the function under test ---
       let loaded_keypair_result = load_keypair_from_env();

       // Assert the result is Ok and the keypair is correct
       assert!(loaded_keypair_result.is_ok(), "load_keypair_from_env failed for custom format: {:?}", loaded_keypair_result.err());
       let loaded_keypair = loaded_keypair_result.unwrap();

       // Compare the public key derived from the loaded keypair with the original
       assert_eq!(loaded_keypair.public(), expected_public_key, "Loaded keypair public key does not match the original");

       // Optional: Assert the PeerIds match as well
       assert_eq!(PeerId::from(loaded_keypair.public()), PeerId::from(expected_public_key), "Loaded PeerId does not match the original");

       // Clean up environment variable
       std::env::remove_var("CLEF_PRIVEE_RELAI");
   }

   #[test]
   fn test_clef_privée_relai_env_key_loading_invalid_base64() {
       // Set invalid base64 data
       std::env::set_var("CLEF_PRIVEE_RELAI", "this is not base64!");

       // --- Actually call the function under test ---
       let loaded_keypair_result = load_keypair_from_env();

       // Assert the result is Err
       assert!(loaded_keypair_result.is_err(), "load_keypair_from_env should have failed for invalid base64");
       // Optionally check the error message contains "base64"
       assert!(loaded_keypair_result.err().unwrap().to_string().contains("base64"));


       // Clean up environment variable
       std::env::remove_var("CLEF_PRIVEE_RELAI");
   }

    #[test]
   fn test_clef_privée_relai_env_key_loading_invalid_protobuf() {
       // Set valid base64, but invalid protobuf data (e.g., just "hello")
       let invalid_protobuf_b64 = base64_engine.encode(b"hello");
       std::env::set_var("CLEF_PRIVEE_RELAI", &invalid_protobuf_b64);

       // --- Actually call the function under test ---
       let loaded_keypair_result = load_keypair_from_env();

       // Assert the result is Err
       assert!(loaded_keypair_result.is_err(), "load_keypair_from_env should have failed for invalid protobuf bytes");
       // Optionally check the error message contains "protobuf" or "decode"
       let err_msg = loaded_keypair_result.err().unwrap().to_string();
       assert!(err_msg.contains("protobuf") || err_msg.contains("decode"));


       // Clean up environment variable
       std::env::remove_var("CLEF_PRIVEE_RELAI");
   }

    #[test]
   fn test_clef_privée_relai_env_key_loading_not_set() {
       // Ensure the environment variable is not set
       std::env::remove_var("CLEF_PRIVEE_RELAI");

       // --- Actually call the function under test ---
       let loaded_keypair_result = load_keypair_from_env();

       // Assert the result is Ok (should generate a random key)
       assert!(loaded_keypair_result.is_ok(), "load_keypair_from_env should succeed when env var is not set");

       // We can't easily check if it's *random*, but we know it succeeded.
       let _loaded_keypair = loaded_keypair_result.unwrap();
   }

    // Integration test for peer connection
    #[tokio::test]
    async fn test_peer_connects_to_relay() {
        // Use a short timeout for the test
        let test_timeout = Duration::from_secs(15); // Increased timeout slightly

        tokio::time::timeout(test_timeout, async {
            // 1. Setup: Generate keys and build swarms
            let relay_key = Keypair::generate_ed25519();
            let relay_peer_id = PeerId::from(relay_key.public());
            let mut relay_swarm = build_swarm(relay_key, None).await.expect("Relay swarm build failed"); // No pubsub topics needed for this test

            let client_key = Keypair::generate_ed25519();
            let client_peer_id = PeerId::from(client_key.public());
            let mut client_swarm = build_swarm(client_key, None).await.expect("Client swarm build failed"); // No pubsub topics needed

            // 2. Start Relay Listener
            relay_swarm.listen_on("/ip4/127.0.0.1/tcp/0".parse().unwrap()).expect("Relay listen failed");

            // 3. Get Relay Listening Address
            let relay_addr = loop {
                if let Some(SwarmEvent::NewListenAddr { address, .. }) = relay_swarm.next().await {
                    // Ensure it's not a loopback WebSocket address if WS is enabled by default elsewhere
                    // For this test, we expect the TCP listener.
                    if address.to_string().contains("/tcp/") {
                         println!("Relay listening on: {}", address); // Use println for test output
                         break address;
                    }
                }
                // Add a small delay to prevent tight looping if the event isn't immediate
                tokio::time::sleep(Duration::from_millis(50)).await;
            };

            // 4. Client Dials Relay
            client_swarm.dial(relay_addr.clone()).expect("Client dial failed");
            println!("Client ({}) dialing Relay ({}) at {}", client_peer_id, relay_peer_id, relay_addr);

            // 5. Event Loop: Wait for connection
            let mut client_connected = false;
            let mut relay_saw_client = false;

            loop {
                tokio::select! {
                    // Poll Relay Swarm
                    relay_event = relay_swarm.select_next_some() => {
                        if let SwarmEvent::ConnectionEstablished { peer_id, .. } = relay_event {
                            println!("Relay saw connection from: {}", peer_id);
                            if peer_id == client_peer_id {
                                relay_saw_client = true;
                            }
                        }
                        // Optional: Log other relay events for debugging
                        // else { println!("Relay event: {:?}", relay_event); }
                    },
                    // Poll Client Swarm
                    client_event = client_swarm.select_next_some() => {
                         if let SwarmEvent::ConnectionEstablished { peer_id, .. } = client_event {
                            println!("Client saw connection to: {}", peer_id);
                            if peer_id == relay_peer_id {
                                client_connected = true;
                            }
                        }
                        // Optional: Log other client events for debugging
                        // else { println!("Client event: {:?}", client_event); }
                    },
                    // Timeout guard (handled by outer tokio::time::timeout)
                    // _ = tokio::time::sleep(Duration::from_secs(10)) => { // Inner timeout as safeguard
                    //     panic!("Test timed out waiting for connection");
                    // }
                }

                // Check if connection is established from both perspectives
                if client_connected && relay_saw_client {
                    println!("Connection successfully established between client and relay.");
                    break; // Success
                }
            }

            // 6. Assertions (already implicitly checked by reaching the end without panic/timeout)
            assert!(client_connected, "Client should have connected to the relay");
            assert!(relay_saw_client, "Relay should have seen the client connection");

        }).await.expect("Test timed out"); // Panic if the outer timeout expires
    }
}

impl From<ping::Event> for RelayEvent {
    fn from(event: ping::Event) -> Self {
        RelayEvent::Ping(event)
    }
}

impl From<identify::Event> for RelayEvent {
    fn from(event: identify::Event) -> Self {
        RelayEvent::Identify(event)
    }
}

impl From<GossipsubEvent> for RelayEvent {
    fn from(event: GossipsubEvent) -> Self {
        RelayEvent::Pubsub(event)
    }
}


// Type alias for the shared state of listening addresses
type ListeningAddresses = Arc<Mutex<Vec<Multiaddr>>>;

// Function now returns a Result
fn load_keypair_from_env() -> Result<Keypair, Box<dyn Error>> {
    match env::var("CLEF_PRIVEE_RELAI") {
        Ok(key_b64) => {
            // 1. Decode Base64
            let key_bytes = base64_engine.decode(key_b64.as_bytes())
                .or_else(|_| STANDARD_NO_PAD.decode(key_b64.as_bytes()))
                .map_err(|e| format!("Failed to decode CLEF_PRIVEE_RELAI from base64: {}", e))?;

            // --- Attempt 1: Check if the decoded bytes look like the JS library's raw Ed25519 key (64 bytes: secret + public) ---
            if key_bytes.len() == 64 {
                info!("Decoded base64 data is 64 bytes long. Assuming JS format (secret + public). Attempting to load using first 32 bytes as Ed25519 secret key.");
                // Extract the first 32 bytes, assuming they are the secret key.
                let mut secret_bytes_array: [u8; 32] = key_bytes[0..32].try_into()
                    .map_err(|_| "Internal error: Failed to extract first 32 bytes from 64-byte key data".to_string())?; // Should not fail

                match Keypair::ed25519_from_bytes(&mut secret_bytes_array) {
                    Ok(keypair) => {
                        info!("Successfully loaded Ed25519 identity from CLEF_PRIVEE_RELAI (extracted 32 secret bytes from 64-byte JS format).");
                        return Ok(keypair); // Success! Return early.
                    }
                    Err(e) => {
                        warn!("Failed to create Ed25519 keypair from extracted 32 bytes (from 64-byte data): {}. Proceeding to other formats...", e);
                        // Fall through to try other decoding methods
                    }
                }
            // --- Attempt 2: Check if the decoded bytes look like *just* the raw Ed25519 secret key (32 bytes) ---
            } else if key_bytes.len() == 32 {
                info!("Decoded base64 data is 32 bytes long. Attempting to load as raw Ed25519 secret key.");
                let mut secret_bytes_array: [u8; 32] = key_bytes.as_slice().try_into()
                    .map_err(|_| "Internal error: Failed to convert 32-byte Vec<u8> to [u8; 32]".to_string())?;

                match Keypair::ed25519_from_bytes(&mut secret_bytes_array) {
                    Ok(keypair) => {
                        info!("Successfully loaded Ed25519 identity from CLEF_PRIVEE_RELAI (raw 32 secret bytes format).");
                        return Ok(keypair); // Success! Return early.
                    }
                    Err(e) => {
                        warn!("Failed to create Ed25519 keypair from 32-byte raw data: {}. Proceeding to other formats...", e);
                        // Fall through
                    }
                }
            } else {
                info!("Decoded base64 data is {} bytes long. Not treating as raw Ed25519 secret (32 or 64 bytes). Trying protobuf formats...", key_bytes.len());
            }

            // --- Attempt 3: Decode using standard libp2p Keypair protobuf encoding ---
            match Keypair::from_protobuf_encoding(&key_bytes) {
                Ok(keypair) => {
                    info!("Successfully loaded identity from CLEF_PRIVEE_RELAI (standard libp2p protobuf format).");
                    Ok(keypair)
                }
                Err(libp2p_decode_err) => {
                    // Standard decoding failed, log it and try the custom format
                    warn!("Failed to decode CLEF_PRIVEE_RELAI as standard libp2p keypair ({}). Trying custom protobuf format...", libp2p_decode_err);

                    // --- Attempt 3: Decode using custom identity.proto definition ---
                    // Need Bytes::from for prost decoding. Clone key_bytes as it might be needed if this fails.
                    match identity_proto::PrivateKey::decode(Bytes::from(key_bytes.clone())) {
                        Ok(private_key_proto) => {
                            // Custom protobuf decoded, now extract the key material
                            match identity_proto::KeyType::try_from(private_key_proto.r#type) {
                                Ok(identity_proto::KeyType::Ed25519) => {
                                    if private_key_proto.data.len() == 32 {
                                        let mut secret_bytes: [u8; 32] = private_key_proto.data.as_slice().try_into()
                                            .map_err(|_| format!("Custom protobuf: Failed to convert data Vec<u8> (len {}) to [u8; 32]", private_key_proto.data.len()))?;
                                        let keypair = Keypair::ed25519_from_bytes(&mut secret_bytes)
                                            .map_err(|e| format!("Custom protobuf: Failed to create Ed25519 keypair from data bytes: {}", e))?;
                                        info!("Successfully loaded Ed25519 identity from CLEF_PRIVEE_RELAI (custom protobuf format).");
                                        Ok(keypair)
                                    } else {
                                        Err(format!("Custom protobuf: Extracted Ed25519 data is not 32 bytes long (found {} bytes)", private_key_proto.data.len()).into())
                                    }
                                }
                                Ok(other_type) => Err(format!("Custom protobuf: Unsupported key type ({:?})", other_type).into()),
                                Err(_) => Err(format!("Custom protobuf: Invalid key type enum value ({})", private_key_proto.r#type).into()),
                            }
                        }
                        Err(custom_decode_err) => {
                            // All decoding attempts failed (raw 64, raw 32, standard proto, custom proto)
                            Err(format!("Failed to decode CLEF_PRIVEE_RELAI: Not valid raw 64-byte JS format, not valid raw 32-byte secret, Standard proto decode error: '{}', Custom proto decode error: '{}'", libp2p_decode_err, custom_decode_err).into())
                        }
                    }
                }
            }
        },
        Err(env::VarError::NotPresent) => {
            // Environment variable not set, generate a new random keypair
            info!("CLEF_PRIVEE_RELAI not set. Generating random identity.");
            Ok(Keypair::generate_ed25519())
        },
        Err(e) => {
            // Other error reading environment variable
            Err(format!("Error reading CLEF_PRIVEE_RELAI environment variable: {}", e).into())
        }
    }
}

// Helper function to build a configured Swarm
async fn build_swarm(local_key: Keypair, pubsub_topics: Option<String>) -> Result<libp2p::swarm::Swarm<RelayBehaviour>, Box<dyn Error>> {
    let local_peer_id = PeerId::from(local_key.public());
    info!("Building swarm for Peer ID: {}", local_peer_id); // Added logging

    // Create the Identify behaviour configuration
    let identify_config = identify::Config::new(
        "/libp2p-relay-rust/0.1.0".to_string(),
        local_key.public(),
    )
    .with_agent_version(format!("rust-libp2p-relay/{}", env!("CARGO_PKG_VERSION")))
    // Explicitly set a longer identify push interval (default is 5 mins)
    .with_interval(Duration::from_secs(600)); // 10 minutes

    // Build the transport
    let transport = {
        let tcp_transport = libp2p::tcp::tokio::Transport::new(libp2p::tcp::Config::default().nodelay(true))
            .upgrade(Version::V1Lazy)
            .authenticate(noise::Config::new(&local_key)?)
            .multiplex(libp2p::yamux::Config::default())
            .timeout(Duration::from_secs(20))
            .boxed();

        let ws_transport = libp2p::websocket::WsConfig::new(
            libp2p::tcp::tokio::Transport::new(libp2p::tcp::Config::default().nodelay(true))
        )
            .upgrade(Version::V1Lazy)
            .authenticate(noise::Config::new(&local_key)?)
            .multiplex(libp2p::yamux::Config::default())
            .timeout(Duration::from_secs(20))
            .boxed();

        let tcp_or_ws_transport = tcp_transport.or_transport(ws_transport).boxed();

        {
            let dns = TokioDnsConfig::system(tcp_or_ws_transport)?;
            dns.map(|either, _| match either {
                Either::Left((peer_id, muxer)) | Either::Right((peer_id, muxer)) => (peer_id, muxer),
            }).boxed()
        }
    };

    // Create the behaviour
    let behaviour = {
        let mut gossipsub = Gossipsub::new(
            MessageAuthenticity::Signed(local_key.clone()), // Use the passed-in key
            GossipsubConfig::default(),
        )?; // Added ? for error handling
        if let Some(topics_str) = &pubsub_topics {
            for name in topics_str.split(',') {
                let topic = Sha256Topic::new(name.trim());
                if gossipsub.subscribe(&topic).is_err() {
                     error!("Failed to subscribe to topic: {}", name.trim()); // Log subscription errors
                } else {
                     info!("Peer {} subscribed to topic: {}", local_peer_id, name.trim());
                }
            }
        }
        RelayBehaviour {
           relay: relay::Behaviour::new(local_peer_id, Default::default()),
           ping: ping::Behaviour::new(ping::Config::new()),
           identify: identify::Behaviour::new(identify_config),
           pubsub: gossipsub,
       }
    };

    // Build the Swarm
    let swarm = SwarmBuilder::with_existing_identity(local_key) // Use the passed-in key
        .with_tokio()
        .with_other_transport(|_| Ok(transport))? // Pass the built transport
        .with_behaviour(|_| Ok(behaviour))? // Pass the built behaviour
        .with_swarm_config(|c| c
            .with_idle_connection_timeout(Duration::from_secs(60))
            // Increase the limit for concurrently negotiating inbound streams
            .with_max_negotiating_inbound_streams(100)
        )
        .build();

    Ok(swarm)
}


#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Load environment variables from .env file, ignore errors (e.g., file not found)
    dotenv().ok();
    env_logger::builder().filter_level(LevelFilter::Info).init();

    info!("Starting Rust libp2p relay node...");

    // --- Configuration Loading ---
    let domain_name = env::var("DOMAINE").ok(); // Optional domain name
    let pubsub_topics = env::var("RELAY_PUBSUB_PEER_DISCOVERY_TOPICS").ok(); // Optional pubsub topics

    // Log the loaded optional config
    if let Some(domain) = &domain_name {
        info!("Using domain: {}", domain);
    } else {
        info!("No DOMAINE environment variable found.");
    }
    if let Some(topics) = &pubsub_topics {
        info!("PubSub discovery topics configured: {}", topics);
        // TODO: Use these topics when pubsub is implemented
    } else {
        info!("No RELAY_PUBSUB_PEER_DISCOVERY_TOPICS environment variable found.");
    }

    // Create shared state for listening addresses
    let listening_addresses: ListeningAddresses = Arc::new(Mutex::new(Vec::new()));

    // Create keypair for the node's identity, handling potential errors
    let local_key = match load_keypair_from_env() {
        Ok(kp) => kp,
        Err(e) => {
            // Log the specific error and exit
            error!("Fatal error loading keypair: {}", e);
            return Err(e); // Propagate the error to exit main
        }
    };

    let local_peer_id = PeerId::from(local_key.public());
    info!("Local peer ID: {}", local_peer_id);

    // Build the Swarm using the helper function
    let mut swarm = build_swarm(local_key.clone(), pubsub_topics).await?;
    // Initialize PubSub relayer state
    let mut relay_reqs: HashMap<PeerId, HashSet<String>> = HashMap::new();
    let always_relay: Vec<String> = vec!["réseau-constellation".to_string()];


    // Define listening addresses
    // Listen on all interfaces for TCP (port 0 asks OS for a free port)
    let listen_addr_tcp = "/ip4/0.0.0.0/tcp/0".parse::<Multiaddr>()?;
    swarm.listen_on(listen_addr_tcp)?;

    // Listen on all interfaces for WebSocket on port 12345
    let listen_addr_ws = "/ip4/0.0.0.0/tcp/12345/ws".parse::<Multiaddr>()?;
    swarm.listen_on(listen_addr_ws)?;
    // Also listen on WebRTC multiaddr for direct peer connections, skip if unsupported
    let webrtc_addr_str = format!("/webrtc/p2p/{}", local_peer_id);
    match webrtc_addr_str.parse::<Multiaddr>() {
        Ok(addr) => {
            if let Err(e_transport) = swarm.listen_on(addr) {
                warn!("WebRTC multiaddr unsupported or failed to listen ({}), skipping: {}", webrtc_addr_str, e_transport);
            }
        }
        Err(e) => {
            warn!("WebRTC multiaddr unsupported or failed to parse ({}), skipping: {}", webrtc_addr_str, e);
        }
    }

    // If a domain name is provided, also try listening on a DNS address.
    // This helps ensure the address is advertised correctly via Identify.
    if let Some(domain) = &domain_name {
        // Use dns4 for IPv4 or dns6 for IPv6, or just dns if agnostic
        let listen_addr_ws_dns = format!("/dns4/{}/tcp/12345/ws", domain).parse::<Multiaddr>();
        match listen_addr_ws_dns {
            Ok(addr) => {
                // Advertise the DNS address rather than listening on it
                swarm.add_external_address(addr.clone());
                info!("Advertising DNS address: {}", addr);
            }
            Err(e) => {
                error!("Failed to parse DNS address from domain {}: {}", domain, e);
            }
        }
    }


    // Clone Arc for the web server task
    let server_listening_addresses = listening_addresses.clone();

    // Spawn the web server task
    tokio::spawn(async move {
        info!("Starting web server on port 8000...");

        // Route for serving index.html at the root
        let index_html_content = include_str!("index.html"); // Embed index.html content
        let index_route = warp::path::end() // Match the root path "/"
            .map(move || warp::reply::html(index_html_content));

        // Route for serving listening addresses at /adresses
        let addresses_route = warp::path("adresses")
            .and(warp::get()) // Match GET requests
            .map(move || {
                let addrs = server_listening_addresses.lock();
                // Filter out loopback addresses like the JS example if desired
                // let public_addrs: Vec<_> = addrs.iter()
                //     .filter(|a| !a.to_string().starts_with("/ip4/127.0.0.1"))
                //     .cloned()
                //     .collect();
                // warp::reply::json(&public_addrs) // Use this line to filter
                warp::reply::json(&*addrs) // Serve all addresses for now
            });

        let routes = index_route.or(addresses_route);

        warp::serve(routes)
            .run(([0, 0, 0, 0], 8000)) // Listen on all interfaces, port 8000
            .await;
    });


    // Create a periodic timer for status logging
    let mut status_interval = interval(Duration::from_secs(30));
    // Initial status log to avoid waiting for first interval tick
    {
        let info = swarm.network_info();
        let counters = info.connection_counters();
        let peers: Vec<_> = swarm.connected_peers().cloned().collect();
        info!(
            "Initial Status: Connected Peers: {} {:?}, Connections: {{ pending_in: {}, pending_out: {}, established_in: {}, established_out: {}, established: {} }}",
            peers.len(),
            peers,
            counters.num_pending_incoming(),
            counters.num_pending_outgoing(),
            counters.num_established_incoming(),
            counters.num_established_outgoing(),
            counters.num_established()
        );
    }

    // Main event loop
    loop {
        tokio::select! {
            // Branch for the status interval timer
            _ = status_interval.tick() => {
                let info = swarm.network_info();
                let counters = info.connection_counters();
                let peers: Vec<_> = swarm.connected_peers().cloned().collect();
                info!(
                    "Status: Connected Peers: {} {:?}, Connections: {{ pending_in: {}, pending_out: {}, established_in: {}, established_out: {}, established: {} }}",
                    peers.len(),
                    peers,
                    counters.num_pending_incoming(),
                    counters.num_pending_outgoing(),
                    counters.num_established_incoming(),
                    counters.num_established_outgoing(),
                    counters.num_established()
                );
            }
            event = swarm.select_next_some() => {
                 // Clone Arc for use inside this match arm if needed later
                 let addresses_for_event = listening_addresses.clone();
                match event {
                    SwarmEvent::NewListenAddr { address, .. } => {
                        info!("Local node listening on: {}", address);
                        // Add the new address to our shared list
                        addresses_for_event.lock().push(address.clone());
                    }
                     SwarmEvent::ExpiredListenAddr { address, .. } => {
                        info!("Local node stopped listening on: {}", address);
                        // Remove the expired address from our shared list
                        addresses_for_event.lock().retain(|a| *a != address);
                    }
                    SwarmEvent::Behaviour(RelayEvent::Identify(identify::Event::Received { peer_id, info, .. })) => {
                        info!("Identified Peer: {} with agent version: {}", peer_id, info.agent_version);
                        // Add addresses observed by Identify to the Swarm's address book
                        for addr in info.listen_addrs {
                             swarm.add_external_address(addr);
                        }
                    }
                    SwarmEvent::Behaviour(RelayEvent::Ping(event)) => {
                         info!("Ping event: {:?}", event);
                    }
                    SwarmEvent::Behaviour(RelayEvent::Relay(event)) => {
                        // Handle events emitted by the relay::Behaviour
                        match event {
                            // Combine logging for initial acceptance and renewals
                            relay::Event::ReservationReqAccepted { src_peer_id, renewed, .. } => {
                                if renewed {
                                    info!("Relay reservation renewed for client: {}", src_peer_id);
                                } else {
                                    info!("Client {} successfully reserved relay hop", src_peer_id);
                                }
                            }
                            // Add other specific relay::Event variants if needed, e.g., ReservationTimedOut
                            relay::Event::ReservationTimedOut { src_peer_id, .. } => {
                                warn!("Relay reservation timed out for client: {}", src_peer_id);
                            }
                            // Catch-all for other relay events
                            _ => {
                                info!("Relay event: {:?}", event);
                            }
                        }
                    }
                    SwarmEvent::Behaviour(RelayEvent::Pubsub(event)) => {
                        // Relay subscriptions: track other peers and mirror their topics
                        match event {
                            GossipsubEvent::Subscribed { peer_id, topic } => {
                                let topics = relay_reqs.entry(peer_id.clone()).or_default();
                                topics.insert(topic.to_string());
                                // Subscribe to the union of all peer topics
                                let all: HashSet<_> = relay_reqs.values().flatten().cloned().collect();
                                for t in &all {
                                    swarm.behaviour_mut().pubsub.subscribe(&Sha256Topic::new(t.clone())).unwrap();
                                }
                            }
                            GossipsubEvent::Unsubscribed { peer_id, topic } => {
                                if let Some(topics) = relay_reqs.get_mut(&peer_id) {
                                    topics.remove(&topic.to_string());
                                }
                                // Recompute union (including always_relay)
                                let mut all: HashSet<_> = relay_reqs.values().flatten().cloned().collect();
                                for t in &always_relay {
                                    all.insert(t.clone());
                                }
                                for t in &all {
                                    swarm.behaviour_mut().pubsub.subscribe(&Sha256Topic::new(t.clone())).unwrap();
                                }
                            }
                            _ => {
                                info!("PubSub event: {:?}", event);
                            }
                        }
                    }
                    SwarmEvent::ConnectionEstablished { peer_id, endpoint, .. } => {
                        info!("Connection established with: {} on {:?}", peer_id, endpoint.get_remote_address());
                        // Log connected peers count immediately after establishment
                        let connected_peers_count = swarm.connected_peers().count();
                        info!("Connected peers count after establishment: {}", connected_peers_count);
                    }
                    SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
                        info!("Connection closed with: {}. Reason: {:?}", peer_id, cause);
                        // Log connected peers count immediately after closure
                        let connected_peers_count = swarm.connected_peers().count();
                        info!("Connected peers count after closure: {}", connected_peers_count);
                    }
                    // Added `..` to ignore unmentioned fields like connection_id
                    SwarmEvent::IncomingConnection { local_addr, send_back_addr, .. } => {
                        info!("Incoming connection from {} to {}", send_back_addr, local_addr);
                    }
                    // Added `..` to ignore unmentioned fields like connection_id
                    SwarmEvent::IncomingConnectionError { local_addr, send_back_addr, error, .. } => {
                        error!("Incoming connection error from {} to {}: {}", send_back_addr, local_addr, error);
                    }
                    SwarmEvent::OutgoingConnectionError { peer_id, error, .. } => {
                        error!("Outgoing connection error to {:?}: {}", peer_id, error);
                    }
                    SwarmEvent::ListenerError { listener_id, error } => {
                        error!("Listener error for {:?}: {}", listener_id, error);
                    }
                     SwarmEvent::ListenerClosed { listener_id, reason, .. } => {
                        info!("Listener {:?} closed: {:?}", listener_id, reason);
                    }
                    SwarmEvent::Dialing { peer_id, connection_id } => {
                        info!("Dialing peer: {:?} (connection ID: {:?})", peer_id, connection_id);
                    }
                    _ => {
                        // Handle other swarm events as needed
                        // info!("Unhandled Swarm Event: {:?}", event);
                    }
                }
            }
        }
    }
}
