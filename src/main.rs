use futures::stream::StreamExt;
use futures::future::Either;
use libp2p::{
    core::transport::upgrade::Version, // Added back Version import
    identity::{Keypair},
    noise, ping, relay, identify,
    swarm::{NetworkBehaviour, SwarmEvent},
    /* Removed unused tcp import */ Multiaddr, PeerId, SwarmBuilder, Transport,
    /* Removed unused dns import */
    // Removed unused websocket import, access via libp2p::websocket
};
use std::{env, error::Error, time::Duration}; // Added env for environment variables
use std::sync::Arc; // Added Arc
use parking_lot::Mutex;
use tokio::time::interval;
use log::{info, error, warn}; // Added warn
use warp::Filter;
use dotenvy::dotenv; // Added dotenvy import
use base64::{engine::general_purpose::STANDARD as base64_engine, Engine as _}; // Added base64 imports
use libp2p::gossipsub::{Behaviour as Gossipsub, Config as GossipsubConfig, MessageAuthenticity, Topic, Event as GossipsubEvent}; // Updated PubSub imports
use libp2p::gossipsub::TopicHash; // gossipsub TopicHash type


// Define the network behaviour combining multiple protocols
#[derive(NetworkBehaviour)]
// The `relay::Behaviour` emits `void::Void`, so we don't need a custom event for it.
// The overall event type `RelayEvent` will be generated by the derive macro.
#[behaviour(to_swarm = "RelayEvent")]
struct RelayBehaviour {
    // Note: relay::Behaviour<RelayReservation> is the full type, but Behaviour often suffices.
    relay: relay::Behaviour,
    ping: ping::Behaviour,
    identify: identify::Behaviour,
    pubsub: Gossipsub, // Added gossipsub behaviour
}

// Define the custom event type that the behaviour emits to the Swarm.
// The derive macro automatically generates variants for behaviours that emit events.
// Since relay::Behaviour emits void::Void, we only need variants for Ping and Identify.
#[derive(Debug)]
enum RelayEvent {
    Ping(ping::Event),
    Identify(identify::Event),
    Relay(relay::Event), // Added Relay variant
    Pubsub(GossipsubEvent), // Added PubSub variant
}

// From implementations are needed for all variants the derive macro maps.

impl From<relay::Event> for RelayEvent {
    fn from(event: relay::Event) -> Self {
        RelayEvent::Relay(event)
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    // Removed duplicate super import
    use libp2p::{
        ping, identify, // Removed relay import as it's not used directly in tests now
        identity::Keypair,
        PeerId, Multiaddr, StreamProtocol,
        swarm::ConnectionId,
        // Removed relay::client import
    };
    use std::num::NonZeroU32; // Import NonZeroU32

    // Helper to create a dummy PeerId for testing
    fn dummy_peer_id() -> PeerId {
        PeerId::from(Keypair::generate_ed25519().public())
    }

    // Helper to create a dummy Multiaddr for testing
    fn dummy_multiaddr() -> Multiaddr {
        "/ip4/127.0.0.1/tcp/0".parse().unwrap()
    }

    // Removed test_from_relay_client_event as relay::Behaviour no longer emits these events directly
    // in a way that maps to our RelayEvent enum.

    #[test]
    fn test_from_ping_event() {
        let peer_id = dummy_peer_id();
        let ping_event = ping::Event {
            peer: peer_id,
            connection: ConnectionId::new_unchecked(0), // Use new_unchecked for simplicity in test
            // Ping result is now directly Result<Duration, Failure>
            result: Result::Ok(Duration::from_millis(10)),
        };
        let event: RelayEvent = ping_event.into();
        assert!(matches!(event, RelayEvent::Ping(ping::Event { result: Ok(_), .. }))); // Adjusted match slightly
    }

    #[test]
    fn test_from_identify_event() {
        let peer_id = dummy_peer_id();
        let public_key = Keypair::generate_ed25519().public();
        let identify_event = identify::Event::Received {
            peer_id,
            info: identify::Info {
                public_key,
                protocol_version: "test/1.0".to_string(),
                agent_version: "test-agent/0.1".to_string(),
                listen_addrs: vec![dummy_multiaddr()],
                // Use StreamProtocol::new for protocol names
                protocols: vec![StreamProtocol::new("/test/1")],
                observed_addr: dummy_multiaddr(),
            },
            connection_id: ConnectionId::new_unchecked(0), // Added missing field
        };
        let event: RelayEvent = identify_event.into();
        assert!(matches!(event, RelayEvent::Identify(identify::Event::Received { .. })));
    }

    // Example test for a SwarmEvent pattern match (demonstrates structure, not a real unit test)
    // This kind of test is more suited for integration tests where a real Swarm exists.
    #[test]
    fn test_swarm_event_match_structure() {
        let peer_id = dummy_peer_id();
        let dummy_endpoint = libp2p::core::ConnectedPoint::Listener {
             local_addr: dummy_multiaddr(),
             send_back_addr: dummy_multiaddr(),
        };
        // Correct the type annotation for SwarmEvent (only one generic argument)
        let event: SwarmEvent<RelayEvent> = SwarmEvent::ConnectionEstablished {
            peer_id,
            connection_id: ConnectionId::new_unchecked(0),
            endpoint: dummy_endpoint,
            // Use NonZeroU32 for num_established
            num_established: NonZeroU32::new(1).unwrap(),
            concurrent_dial_errors: None,
            established_in: Duration::from_secs(0),
        };

        match event {
             SwarmEvent::ConnectionEstablished { peer_id: p, endpoint: e, num_established, .. } => {
                 assert_eq!(p, peer_id);
                 assert!(matches!(e, libp2p::core::ConnectedPoint::Listener{..}));
                 // Compare with the correct NonZeroU32 value
                 assert_eq!(num_established, NonZeroU32::new(1).unwrap());
             },
             _ => panic!("Event did not match expected pattern"),
        }
    }

   #[test]
   fn test_relay_behaviour_construction() {
       let local_key = Keypair::generate_ed25519();
       let local_peer_id = PeerId::from(local_key.public());
       let identify_config = identify::Config::new(
           "/test-protocol/1.0".to_string(),
           local_key.public(),
       );

       // Prefix with underscore to silence unused variable warning
       let _behaviour = RelayBehaviour {
           relay: relay::Behaviour::new(local_peer_id, Default::default()),
           ping: ping::Behaviour::new(ping::Config::new()),
           identify: identify::Behaviour::new(identify_config.clone()), // Clone config for assertion
           pubsub: Gossipsub::new(MessageAuthenticity::Anonymous, GossipsubConfig::default()).unwrap(),
       };

       // Basic assertion to ensure the behaviour fields are populated.
       // More detailed checks might involve inspecting behaviour states if APIs allow,
       // but often just checking construction is sufficient for a unit test.
       // Cannot directly access config from behaviour, rely on test_identify_config_creation
       // assert_eq!(behaviour.identify.config().protocol_version, identify_config.protocol_version);

       // Ping and Relay behaviours don't expose simple config getters in the same way easily.
       // We rely on the type system and successful construction.
       // Dummy assertion to ensure the test runs and compiles.
       assert!(true);
   }

   #[test]
   fn test_identify_config_creation() {
       let local_key = Keypair::generate_ed25519();
       let public_key = local_key.public();
       let protocol_version = "/test-identify/1.0".to_string();
       let agent_version = "test-agent/0.1".to_string();

       let config = identify::Config::new(
           protocol_version.clone(),
           public_key.clone(),
       )
       .with_agent_version(agent_version.clone());

       assert_eq!(config.protocol_version(), protocol_version);
       // Field name changed from public_key to local_public_key
       assert_eq!(config.local_public_key(), public_key);
       assert_eq!(config.agent_version(), agent_version);
       // initial_delay field removed or changed, remove assertion
       // assert_eq!(config.initial_delay, Duration::from_millis(500));
       // Check default interval instead (adjust if libp2p defaults change)
       assert_eq!(config.interval(), Duration::from_secs(5 * 60));
   }
}

impl From<ping::Event> for RelayEvent {
    fn from(event: ping::Event) -> Self {
        RelayEvent::Ping(event)
    }
}

impl From<identify::Event> for RelayEvent {
    fn from(event: identify::Event) -> Self {
        RelayEvent::Identify(event)
    }
}

impl From<GossipsubEvent> for RelayEvent {
    fn from(event: GossipsubEvent) -> Self {
        RelayEvent::Pubsub(event)
    }
}


// Type alias for the shared state of listening addresses
type ListeningAddresses = Arc<Mutex<Vec<Multiaddr>>>;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Load environment variables from .env file, ignore errors (e.g., file not found)
    dotenv().ok();
    env_logger::init();

    info!("Starting Rust libp2p relay node...");

    // --- Configuration Loading ---
    let private_key_base64 = env::var("CLEF_PRIVEE_RELAI");
    let domain_name = env::var("DOMAINE").ok(); // Optional domain name
    let pubsub_topics = env::var("RELAY_PUBSUB_PEER_DISCOVERY_TOPICS").ok(); // Optional pubsub topics

    // Log the loaded optional config
    if let Some(domain) = &domain_name {
        info!("Using domain: {}", domain);
    } else {
        info!("No DOMAINE environment variable found.");
    }
    if let Some(topics) = &pubsub_topics {
        info!("PubSub discovery topics configured: {}", topics);
        // TODO: Use these topics when pubsub is implemented
    } else {
        info!("No RELAY_PUBSUB_PEER_DISCOVERY_TOPICS environment variable found.");
    }

    // Create shared state for listening addresses
    let listening_addresses: ListeningAddresses = Arc::new(Mutex::new(Vec::new()));

    // Create keypair for the node's identity
    let local_key = match private_key_base64 {
        Ok(key_b64) => {
            match base64_engine.decode(key_b64.as_bytes()) {
                Ok(key_bytes) => {
                    match Keypair::from_protobuf_encoding(&key_bytes) { // Corrected function name
                        Ok(keypair) => {
                            info!("Loaded identity from CLEF_PRIVEE_RELAI (protobuf).");
                            keypair
                        },
                        Err(_) => { // If protobuf fails, try Ed25519 secret key bytes directly
                            match Keypair::ed25519_from_bytes(key_bytes) {
                                Ok(keypair) => {
                                    info!("Loaded identity from CLEF_PRIVEE_RELAI (Ed25519 bytes).");
                                    keypair
                                },
                                Err(e) => {
                                    warn!("Failed to decode CLEF_PRIVEE_RELAI as Ed25519 key: {}. Generating random identity.", e);
                                    Keypair::generate_ed25519()
                                }
                            }
                        }
                    }
                },
                Err(e) => {
                    warn!("Failed to decode CLEF_PRIVEE_RELAI from base64: {}. Generating random identity.", e);
                    Keypair::generate_ed25519()
                }
            }
        },
        Err(_) => {
            info!("CLEF_PRIVEE_RELAI not set. Generating random identity.");
            Keypair::generate_ed25519()
        }
    };

    let local_peer_id = PeerId::from(local_key.public());
    info!("Local peer ID: {}", local_peer_id);

    // Transport construction is now handled by SwarmBuilder below.
    // We only need the configurations.

    // Create the Identify behaviour configuration
    // Note: The Identify protocol ID is now recommended to be just "/ipfs/id/1.0.0"
    // but we keep the custom one for now.
    let identify_config = identify::Config::new(
        "/libp2p-relay-rust/0.1.0".to_string(),
        local_key.public(),
    )
    .with_agent_version(format!("rust-libp2p-relay/{}", env!("CARGO_PKG_VERSION")));


    // Build the transport: Combine DNS, TCP, and WebSocket
    let transport = {
        // Create TCP transport
        let tcp_transport = libp2p::tcp::tokio::Transport::new(libp2p::tcp::Config::default().nodelay(true))
            .upgrade(Version::V1Lazy)
            .authenticate(noise::Config::new(&local_key)?)
            .multiplex(libp2p::yamux::Config::default())
            .timeout(Duration::from_secs(20)) // Add connection timeout
            .boxed();

        // Create WebSocket transport using WsConfig
        let ws_transport = libp2p::websocket::WsConfig::new(
            libp2p::tcp::tokio::Transport::new(libp2p::tcp::Config::default().nodelay(true))
        )
            // Apply the same upgrade and authentication as TCP
            .upgrade(Version::V1Lazy)
            .authenticate(noise::Config::new(&local_key)?)
            .multiplex(libp2p::yamux::Config::default())
            .timeout(Duration::from_secs(20)) // Add connection timeout
            .boxed();

        // Combine TCP and WS transports
        let tcp_or_ws_transport = tcp_transport.or_transport(ws_transport).boxed();

        // Wrap with DNS resolver and normalize output to (PeerId, StreamMuxerBox)
        libp2p::dns::tokio::Transport::system(tcp_or_ws_transport)?
            .map(|either, _endpoint| {
                match either {
                    Either::Left((peer_id, muxer)) |
                    Either::Right((peer_id, muxer)) => (peer_id, muxer),
                }
            })
            .boxed()
    };

    // Create the behaviour
    let behaviour = {
        // Initialize Gossipsub for PubSub peer discovery
        let mut gossipsub = Gossipsub::new(
            MessageAuthenticity::Signed(local_key.clone()),
            GossipsubConfig::default(),
        ).unwrap();
        if let Some(topics_str) = &pubsub_topics {
            for name in topics_str.split(',') {
                let topic = TopicHash::from_raw(name.trim());
                let _ = gossipsub.subscribe(&topic);
            }
        }
        RelayBehaviour {
           relay: relay::Behaviour::new(local_peer_id, Default::default()),
           ping: ping::Behaviour::new(ping::Config::new()),
           identify: identify::Behaviour::new(identify_config), // Use identify_config directly
           pubsub: gossipsub, // Added pubsub
       }
    };

    // Build the Swarm using the manually constructed transport and behaviour
    let mut swarm = SwarmBuilder::with_existing_identity(local_key.clone())
        .with_tokio()
        .with_other_transport(|_| Ok(transport))?
        .with_behaviour(|_| Ok(behaviour))?
        .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))
        .build();


    // Define listening addresses
    // Listen on all interfaces for TCP (port 0 asks OS for a free port)
    let listen_addr_tcp = "/ip4/0.0.0.0/tcp/0".parse::<Multiaddr>()?;
    swarm.listen_on(listen_addr_tcp)?;

    // Listen on all interfaces for WebSocket on the desired port 12345
    let listen_addr_ws_ip = "/ip4/0.0.0.0/tcp/12345/ws".parse::<Multiaddr>()?;
    swarm.listen_on(listen_addr_ws_ip)?;

    // If a domain name is provided, also try listening on a DNS address.
    // This helps ensure the address is advertised correctly via Identify.
    if let Some(domain) = &domain_name {
        // Use dns4 for IPv4 or dns6 for IPv6, or just dns if agnostic
        let listen_addr_ws_dns = format!("/dns4/{}/tcp/12345/ws", domain).parse::<Multiaddr>();
        match listen_addr_ws_dns {
            Ok(addr) => {
                if let Err(e) = swarm.listen_on(addr.clone()) {
                    // Log error if listening on DNS fails, but continue anyway
                    error!("Failed to listen on DNS address {}: {}", addr, e);
                }
            }
            Err(e) => {
                 error!("Failed to parse DNS address from domain {}: {}", domain, e);
            }
        }
    }


    // Clone Arc for the web server task
    let server_listening_addresses = listening_addresses.clone();

    // Spawn the web server task
    tokio::spawn(async move {
        info!("Starting web server on port 8000...");

        // Route for serving index.html at the root
        let index_html_content = include_str!("index.html"); // Embed index.html content
        let index_route = warp::path::end() // Match the root path "/"
            .map(move || warp::reply::html(index_html_content));

        // Route for serving listening addresses at /adresses
        let addresses_route = warp::path("adresses")
            .and(warp::get()) // Match GET requests
            .map(move || {
                let addrs = server_listening_addresses.lock();
                // Filter out loopback addresses like the JS example if desired
                // let public_addrs: Vec<_> = addrs.iter()
                //     .filter(|a| !a.to_string().starts_with("/ip4/127.0.0.1"))
                //     .cloned()
                //     .collect();
                // warp::reply::json(&public_addrs) // Use this line to filter
                warp::reply::json(&*addrs) // Serve all addresses for now
            });

        let routes = index_route.or(addresses_route);

        warp::serve(routes)
            .run(([0, 0, 0, 0], 8000)) // Listen on all interfaces, port 8000
            .await;
    });


    // Create a periodic timer for status logging
    let mut status_interval = interval(Duration::from_secs(30));

    // Main event loop
    loop {
        tokio::select! {
            // Branch for the status interval timer
            _ = status_interval.tick() => {
                let info = swarm.network_info();
                let counters = info.connection_counters();
                info!(
                    "Status: Connected Peers: {}, Connections: {{ pending_in: {}, pending_out: {}, established_in: {}, established_out: {}, established: {} }}",
                    info.num_peers(),
                    counters.num_pending_incoming(),
                    counters.num_pending_outgoing(),
                    counters.num_established_incoming(),
                    counters.num_established_outgoing(),
                    counters.num_established()
                );
            }
            event = swarm.select_next_some() => {
                 // Clone Arc for use inside this match arm if needed later
                 let addresses_for_event = listening_addresses.clone();
                match event {
                    SwarmEvent::NewListenAddr { address, .. } => {
                        info!("Local node listening on: {}", address);
                        // Add the new address to our shared list
                        addresses_for_event.lock().push(address.clone());
                    }
                     SwarmEvent::ExpiredListenAddr { address, .. } => {
                        info!("Local node stopped listening on: {}", address);
                        // Remove the expired address from our shared list
                        addresses_for_event.lock().retain(|a| *a != address);
                    }
                    SwarmEvent::Behaviour(RelayEvent::Identify(identify::Event::Received { peer_id, info, .. })) => {
                        info!("Identified Peer: {} with agent version: {}", peer_id, info.agent_version);
                        // Add addresses observed by Identify to the Swarm's address book
                        for addr in info.listen_addrs {
                             swarm.add_external_address(addr);
                        }
                    }
                    SwarmEvent::Behaviour(RelayEvent::Ping(event)) => {
                         info!("Ping event: {:?}", event);
                    }
                    SwarmEvent::Behaviour(RelayEvent::Relay(event)) => {
                        // Handle events emitted by the relay::Behaviour
                        // These events are related to this node acting *as* a relay (stop/hop)
                        info!("Relay event: {:?}", event);
                    }
                    SwarmEvent::Behaviour(RelayEvent::Pubsub(event)) => {
                        // Handle PubSub peer‐discovery events
                        info!("PubSub event: {:?}", event);
                    }
                    SwarmEvent::ConnectionEstablished { peer_id, endpoint, .. } => {
                        info!("Connection established with: {} on {:?}", peer_id, endpoint.get_remote_address());
                    }
                    SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
                        info!("Connection closed with: {}. Reason: {:?}", peer_id, cause);
                    }
                    // Added `..` to ignore unmentioned fields like connection_id
                    SwarmEvent::IncomingConnection { local_addr, send_back_addr, .. } => {
                        info!("Incoming connection from {} to {}", send_back_addr, local_addr);
                    }
                    // Added `..` to ignore unmentioned fields like connection_id
                    SwarmEvent::IncomingConnectionError { local_addr, send_back_addr, error, .. } => {
                        error!("Incoming connection error from {} to {}: {}", send_back_addr, local_addr, error);
                    }
                    SwarmEvent::OutgoingConnectionError { peer_id, error, .. } => {
                        error!("Outgoing connection error to {:?}: {}", peer_id, error);
                    }
                    SwarmEvent::ListenerError { listener_id, error } => {
                        error!("Listener error for {:?}: {}", listener_id, error);
                    }
                     SwarmEvent::ListenerClosed { listener_id, reason, .. } => {
                        info!("Listener {:?} closed: {:?}", listener_id, reason);
                    }
                    SwarmEvent::Dialing { peer_id, connection_id } => {
                        info!("Dialing peer: {:?} (connection ID: {:?})", peer_id, connection_id);
                    }
                    _ => {
                        // Handle other swarm events as needed
                        // info!("Unhandled Swarm Event: {:?}", event);
                    }
                }
            }
        }
    }
}
